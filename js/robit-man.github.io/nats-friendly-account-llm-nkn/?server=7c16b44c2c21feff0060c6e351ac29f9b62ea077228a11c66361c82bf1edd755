<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Inference Relay</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.min.css">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Radio+Canada:ital,wght@0,300..700;1,300..700&display=swap');
    :root {
      --vh: 1vh;
      --bg-page: #f5f5f5;
      --bg-card: #ffffff;
      --bg-panel: #fafafa;
      --bg-input: #f0f0f0;
      --border-subtle: #dcdcdc;
      --text-main: #1f2933;
      --text-muted: #6b7280;
      --accent: #4b5563;
      --accent-soft: rgba(0, 0, 0, 0.05);
      --radius-card: 1rem;
      --radius-inner: 0.5rem;
      --shadow-card: 0 12px 30px rgba(0, 0, 0, 0.08);
      --grid-dot: rgba(0, 0, 0, 0.06);
      --bubble-user: #e5e7eb;
      --bubble-assistant: #f8f8f8;
      --bubble-border: var(--border-subtle);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: calc(var(--vh, 1vh) * 100);
      font-family: "Radio Canada", sans-serif;
      background-color: var(--bg-page);
      background-image: radial-gradient(circle, var(--grid-dot) 1px, transparent 1px);
      background-size: 24px 24px;
      color: var(--text-main);
      position: relative;
      overflow-x: hidden;
      touch-action: pan-x pan-y;
    }
    a{color:var(--accent);text-decoration:none;}
    input, textarea{
      outline:none!important;
      color: var(--text-main);
    }
    button{
      border: 1px solid var(--border-subtle);
      background: var(--bg-input);
      border-radius: var(--radius-inner);
      padding: 6px 10px;
      cursor: pointer;
      color: var(--text-main);
    }
    .app-shell { min-height: calc(var(--vh, 1vh) * 100); display: flex; flex-direction: column; position: relative; z-index: 1; }
    .app-header {
      padding: 16px 24px;
      display: flex; justify-content: space-between; align-items: center; gap: 16px;
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      box-shadow: var(--shadow-card);
    }
    .app-header-title { font-size: 20px; font-weight: 700; letter-spacing: .08em; text-transform: uppercase; color: var(--text-main); }
    .app-header-sub { font-size: 13px; color: var(--text-muted); }
    .status-pill {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 14px; border-radius: var(--radius-inner); border: 1px solid var(--border-subtle);
      font-size: 12px;
      box-shadow: none;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .status-pill.status-green { background: rgba(34, 197, 94, 0.12); color: #16a34a; }
    .status-pill.status-yellow { background: rgba(234, 179, 8, 0.12); color: #b45309; }
    .status-pill.status-red { background: rgba(239, 68, 68, 0.12); color: #dc2626; }
    .status-pill.status-pink { background: rgba(236, 72, 147, 0.15); color: #ec4899; }
    .model-status-pill {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 14px; border-radius: var(--radius-inner);
      font-size: 12px; font-weight: 600;
      background: #e5e7eb;
      color: var(--text-main);
      border: 1px solid var(--border-subtle);
      box-shadow: none;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      cursor: pointer;
      position: relative;
    }
    .model-status-pill::after {
      content: '▾';
      font-size: 11px;
      color: var(--text-muted);
    }
    .model-status-pill:hover { background: #f0f0f0; transform: translateY(-1px); }
    .model-status-pill[data-phase="idle"] {
      background: rgba(187,247,208,0.35);
      color: #16a34a;
    }
    .model-status-pill[data-phase="loading"] {
      background: rgba(252, 211, 77, 0.35);
      color: #92400e;
    }
    .model-status-pill[data-phase="streaming"] {
      background: rgba(190, 242, 255, 0.35);
      color: #0c4a6e;
    }
    .model-status-pill[data-phase="error"] {
      background: rgba(254,226,226,0.6);
      color: #b91c1c;
    }
    .model-status-wrapper { display: flex; align-items: center; gap: 8px; position: relative; }
    .model-spinner {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 3px solid rgba(0,0,0,0.08);
      border-top-color: var(--accent);
      animation: spinner-rotate 1.2s linear infinite;
    }
    .model-spinner.hidden { display: none; }
    @keyframes spinner-rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .model-metrics {
      display: flex;
      flex-direction: column;
      font-size: 11px;
      color: var(--text-muted);
      gap: 4px;
      min-width: 120px;
    }
    .model-metrics span { display: block; }
    .app-main { flex: 1; padding: 24px 16px 32px; display: flex; justify-content: center; }
    .card {
      width: 100%; max-width: 900px; background: var(--bg-card);
      border-radius: var(--radius-card); box-shadow: var(--shadow-card);
      padding: 28px 30px 26px; display: flex; flex-direction: column; gap: 20px;
    }
    .card-title { font-size: 22px; font-weight: 600; margin: 0; }
    .card-subtitle { font-size: 14px; color: var(--text-muted); }
    .conn-bar {
      justify-content:space-between;
      display: flex; flex-wrap: wrap; gap: 10px; align-items: center;
      background: var(--bg-panel); padding: 16px 18px; border-radius: var(--radius-inner);
      border: 1px solid var(--border-subtle); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.04);
    }
    .conn-bar label { font-size: 12px; text-transform: uppercase; color: var(--text-muted); letter-spacing: 0.04em; }
    .conn-bar input {
      border-radius: var(--radius-inner); border: 1px solid var(--border-subtle);
      background: var(--bg-input); padding: 10px 16px; font-size: 16px;
      box-shadow: none;
    }
    .conn-bar button {
      border-radius: var(--radius-inner); border: 1px solid var(--border-subtle); padding: 10px; font-size: 13px;
      background: var(--accent); color: white; cursor: pointer;
      box-shadow: none;
    }
    .conn-bar button:disabled { opacity: .5; cursor: not-allowed; }
    .auth-section { display: flex; flex-direction: column; gap: 12px; }
    .auth-forms { display: flex; flex-direction: column; gap: 12px; }
    .auth-card {
      background: var(--bg-panel); border: 1px solid var(--border-subtle);
      border-radius: var(--radius-inner); padding: 16px 18px; display: flex; flex-direction: column; gap: 10px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.05);
    }
    .auth-card label { font-size: 12px; text-transform: uppercase; color: var(--text-muted); letter-spacing: 0.04em; }
    .auth-card input {
      border-radius: var(--radius-inner); border: 1px solid var(--border-subtle);
      padding: 10px 14px; font-size: 16px; background: var(--bg-input);
      box-shadow: none;
    }
    .auth-card button {
      align-self: flex-start; padding: 8px 16px; border-radius: var(--radius-inner);
      border: 1px solid var(--border-subtle); background: var(--accent);
      color: #fff; cursor: pointer; box-shadow: none;
    }
  .session-bar {
      display: flex; align-items: center; gap: 12px; justify-content: space-between;
      padding: 12px 16px; border-radius: var(--radius-inner);
      border: 1px solid var(--border-subtle); background: var(--bg-panel);
      flex-shrink: 0; flex-flow: wrap;
      box-shadow: none;
  }
  .session-hardware-inline {
      display: none;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
      min-width: 140px;
  }
  .session-hardware-bar {
      flex: 1;
      height: 5px;
      border-radius: var(--radius-inner);
      background: rgba(0, 0, 0, 0.05);
      overflow: hidden;
      position: relative;
  }
  .session-hardware-bar span {
      position: absolute;
      inset: 0;
      border-radius: var(--radius-inner);
      background: var(--accent);
      width: 0%;
      transition: width 0.4s ease;
  }
  .session-hardware-inline span:last-child {
      white-space: nowrap;
      font-size: 10px;
  }
    .hardware-panel {
      padding: 12px 16px;
      border-radius: var(--radius-inner);
      background: var(--bg-panel);
      border: 1px solid var(--border-subtle);
      box-shadow: none;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .hardware-row {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: space-between;
  }
    .hardware-bar {
      flex: 1;
      height: 6px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: var(--radius-inner);
      overflow: hidden;
      position: relative;
    }
    .hardware-bar span {
      position: absolute;
      inset: 0;
      border-radius: var(--radius-inner);
      background: var(--accent);
      width: 0%;
      transition: width 0.4s ease;
    }
    .sidebar-inline-toggle {
      display: none;
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-inner);
      padding: 6px 10px;
      background: var(--bg-panel);
      color: var(--text-main);
      font-size: 14px;
      cursor: pointer;
      box-shadow: none;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .sidebar-inline-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(0,0,0,0.06);
    }
    .sessions-sidebar.hidden + .card .session-bar .sidebar-inline-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .session-bar button {
      border-radius: var(--radius-inner); border: 1px solid var(--border-subtle);
      background: var(--bg-input); color: var(--text-main); padding: 6px 8px;
      cursor: pointer;
      box-shadow: none;
      height: 2rem;
    }
    .status-log {
      border-radius: var(--radius-inner);
      border: 1px solid var(--border-subtle);
      background: var(--bg-panel);
      padding: 12px 14px;
      min-height: 48px;
      font-size: 12px;
      color: var(--text-muted);
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 160px;
      overflow-y: auto;
    }
    .status-log div.ok { color: #15803d; }
    .status-log div.err { color: #be123c; }
    .chat-messages {
      flex: 1; min-height: 0; overflow-y: auto;
      background: var(--bg-panel); border-radius: var(--radius-inner);
      border: 1px solid var(--border-subtle);
      padding: 24px; display: flex; flex-direction: column; gap: 14px;
      box-shadow: none;
      position: relative;
    }
    .chat-message { display: flex; flex-direction: column; gap: 4px; }
    .chat-message-user { align-items: flex-end; }
    .chat-message-assistant { align-items: flex-start; }
    .chat-meta { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: .12em; color: var(--text-muted); }
.chat-bubble {
  max-width: 86%; padding: 12px 16px; border-radius: var(--radius-inner);
  font-size: 14px; line-height: 1.4; box-shadow: none;
  position: relative;
  overflow: hidden;
}
.chat-bubble-user { background: var(--bubble-user); border: 1px solid var(--bubble-border); }
.chat-bubble-assistant { background: var(--bubble-assistant); border: 1px solid var(--bubble-border); }
    .typing-reveal {
      position: absolute;
      inset: 0;
      background: inherit;
      transform-origin: left;
      animation: typingReveal 260ms ease-out forwards;
      pointer-events: none;
      z-index: 2;
    }
    @keyframes typingReveal {
      0% { transform: scaleX(1); }
      100% { transform: scaleX(0); }
    }
    .chat-input-wrap {
      display: flex; flex-direction: column; gap: 8px;
      flex-shrink: 0;
      max-height: 50%;
    }
    .chat-tools {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 12px;
      color: var(--text-muted);
    }
    .tool-btn {
      border: 1px solid var(--border-subtle);
      background: var(--bg-input);
      border-radius: var(--radius-inner);
      padding: 6px 10px;
      cursor: pointer;
      color: var(--text-main);
    }
    .tool-btn:disabled { 
      opacity: 0.5; 
      cursor: not-allowed; 
    }

  #image-chip{
    padding:0px 10px!important;
  }
  .chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
      border-radius: var(--radius-inner);
    border: 1px solid var(--border-subtle);
    background: var(--bg-input);
    color: var(--text-main);
    font-size: 12px;
  }
  .thinking-chip {
    cursor: pointer;
    position: relative;
    transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
  }
  .thinking-chip input[type="checkbox"] {
    position: absolute;
    inset: 0;
    opacity: 0;
    cursor: pointer;
  }
  .thinking-chip.on {
    background: var(--text-main);
    color: var(--bubble-user);
    border-color: var(--text-muted);
  }
  .thinking-chip .thinking-label {
    pointer-events: none;
  }
.upload-status {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  border-radius: var(--radius-inner);
  border: 1px dashed var(--border-subtle);
  background: var(--bg-panel);
  color: var(--text-main);
  font-size: 12px;
  max-width: 80%;
  flex-wrap: wrap;
}
.upload-status .progress {
  font-weight: 600;
}
    .upload-status .status-icon {
      width: 16px;
      height: 16px;
      display: inline-block;
    }
.upload-status.success { border-color: #22c55e; }
.upload-status.error { border-color: #ef4444; color: #b91c1c; }
.upload-meta {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.upload-name {
  font-weight: 600;
}
.upload-thumb {
  width: 38px;
  height: 38px;
  border-radius: 8px;
  object-fit: cover;
  border: 1px solid var(--border-subtle);
  background: #f8fafc;
}
.upload-retry-btn {
  border: 1px solid var(--border-subtle);
  background: #fff;
  padding: 4px 10px;
  border-radius: var(--radius-inner);
  font-size: 12px;
  cursor: pointer;
}
.upload-retry-btn:hover {
  background: var(--bg-input);
}
.chat-thumb {
  width: 120px;
  height: auto;
  max-height: 160px;
  border: 1px solid var(--border-subtle);
  display: block;
  margin-bottom: 8px;
  object-fit: contain;
}
.theme-toggle {
  border: 1px solid var(--border-subtle);
  background: var(--bg-input);
  border-radius: var(--radius-inner);
  padding: 6px 10px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  color: var(--text-main);
}
.theme-toggle svg {
  width: 18px;
  height: 18px;
}
.theme-toggle:hover {
  background: var(--bg-panel);
}
.theme-dark {
  --bg-page: #0f172a;
  --bg-card: #111827;
  --bg-panel: #0b1220;
  --bg-input: #1f2937;
  --border-subtle: #1f2937;
  --text-main: #e5e7eb;
  --text-muted: #9ca3af;
  --accent: #3b82f6;
  --accent-soft: rgba(59,130,246,0.08);
  --shadow-card: 0 12px 30px rgba(0,0,0,0.35);
  --grid-dot: rgba(255,255,255,0.06);
  --bubble-user: #1f2937;
  --bubble-assistant: #111827;
  --bubble-border: #1f2937;
}
.chat-thumb {
  width: 120px;
  height: auto;
  max-height: 160px;
  border: 1px solid var(--border-subtle);
  display: block;
  margin-bottom: 8px;
  object-fit: contain;
}
    .chip .remove {
      border: none;
      background: transparent;
      cursor: pointer;
      color: var(--text-muted);
      font-size: 14px;
      line-height: 1;
    }
    .chat-input-field {
      position: relative;
      width: 100%;
      max-height: 100%;
      line-height: 1;
      display: flex;
    }
    .chat-input-field-control {
      width: 100%; min-height: 55px; border-radius: var(--radius-inner);
      border: 1px solid var(--border-subtle); padding: 14px 140px 14px 16px;
      font-size: 16px; background: var(--bg-input);
      font-family: inherit; box-shadow: none;
      max-height:100%;
      transition: box-shadow 0.2s ease, border-color 0.2s ease;
      resize: none;
    }
    .chat-input-field-control:focus {
      outline: none;
      border-color: #9ca3af;
      box-shadow: 0 0 0 3px rgba(0,0,0,0.05);
    }
    .chat-input-field-control:disabled {
      background: #e5e7eb;
      cursor: not-allowed;
    }
    .chat-input-field-control.multiline {
      padding-bottom: 90px;
      resize: vertical;
    }
    .chat-input-submit {
      position: absolute;
      bottom: 4px;
      right: 4px;
      border-radius: var(--radius-inner);
      padding: 6px 16px;
      font-size: 13px;
      box-shadow: none;
    }
    .scroll-resume-btn {
      position: absolute;
      bottom: 12px;
      right: 12px;
      z-index: 3;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      border-radius: 999px;
      background: #0b1021;
      color: #e5e7eb;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 6px 14px rgba(0,0,0,0.12);
      font-size: 12px;
      cursor: pointer;
      transition: transform 0.15s ease, opacity 0.15s ease, box-shadow 0.15s ease;
    }
    .scroll-resume-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(0,0,0,0.16);
    }
    .btn {
      background: var(--accent);
      border: 1px solid var(--border-subtle); border-radius: var(--radius-inner);
      padding: 12px 28px; font-size: 14px; color: white; font-weight: 600;
      box-shadow: none; cursor: pointer;
    }
    .btn:disabled { opacity: .6; cursor: not-allowed; }
    .chat-hint { font-size: 12px; color: var(--text-muted); }
    .chat-area {
      display: flex; flex-direction: column; gap: 14px;
      flex: 1; min-height: 0; overflow: visible;
    }
    .reauth-action {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .reauth-action button {
      border-radius: var(--radius-inner);
      padding: 4px 12px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-input);
      color: var(--text-main);
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, opacity 0.2s ease;
    }
    .reauth-action button:hover {
      transform: translateY(-1px);
      opacity: 0.85;
    }
    .chat-area.chat-disabled { opacity: 0.55; pointer-events: none; }
    .hidden { display: none !important; }
    .modal-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.45);
      display: flex; align-items: center; justify-content: center;
      z-index: 1000;
      padding: 20px;
    }
    .modal-content {
      background: var(--bg-card);
      border-radius: var(--radius-card);
      box-shadow: var(--shadow-card);
      padding: 38px 36px; max-width: 520px; width: min(520px, 100%);
      border: 1px solid var(--border-subtle);
      position: relative;
      overflow: hidden;
    }
    .modal-spinner {
      position: absolute !important;
      top: 20px;
      right: 20px;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: 4px solid rgba(0, 0, 0, 0.08);
      border-top-color: var(--accent);
      box-shadow: none;
      animation: modal-spinner-spin 2.4s linear infinite;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .login-modal.state-connect .modal-spinner {
      opacity: 1;
    }
    @keyframes modal-spinner-spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .modal-title {
      font-size: 24px; font-weight: 700; margin: 0 0 8px 0;
      color: var(--text-main);
    }
    .modal-subtitle {
      font-size: 14px; color: var(--text-muted); margin: 0 0 24px 0;
    }

    /* Model picker */
    .model-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 1100;
      backdrop-filter: blur(10px);
    }
    .model-modal.hidden { display: none; }
    .model-modal-content {
      width: min(900px, 100%);
      max-height: calc(100% - 10rem);
      overflow: auto;
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-card);
      box-shadow: var(--shadow-card);
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .pushRight{
      margin-right:auto;
    }
    .tools-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .tool-row {
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-inner);
      padding: 10px 12px;
      background: var(--bg-panel);
      display: flex;
      gap: 12px;
      justify-content: space-between;
      align-items: flex-start;
    }
    .tool-row .tool-meta {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }
    .tool-row .tool-title {
      font-weight: 700;
      color: var(--text-main);
    }
    .tool-row .tool-desc {
      color: var(--text-muted);
      font-size: 12px;
      word-break: break-word;
    }
    .tool-row .tool-actions {
      display: flex;
      gap: 8px;
    }
    .tool-row button {
      border: 1px solid var(--border-subtle);
      background: var(--bg-input);
      border-radius: var(--radius-inner);
      padding: 6px 10px;
      cursor: pointer;
      color: var(--text-main);
    }
    .tool-form {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 8px;
    }
    .tool-form label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--text-muted);
    }
    .tool-form input,
    .tool-form textarea {
      width: 100%;
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-inner);
      padding: 10px 12px;
      background: var(--bg-input);
      font-family: inherit;
    }
    .tool-form textarea {
      min-height: 120px;
      resize: vertical;
    }
    .tool-form .tool-actions-inline {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .tool-form .tool-error {
      color: #b91c1c;
      font-size: 12px;
    }
    .tool-form button[type="submit"] {
      background: var(--accent);
      color: #fff;
    }
    .tool-form-hint {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 4px;
    }
    .model-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .model-modal-title { font-size: 20px; font-weight: 700; margin: 0; }
    .model-modal-sub { margin: 0; color: var(--text-muted); font-size: 13px; }
    .model-modal-close {
      border: 1px solid var(--border-subtle);
      background: var(--bg-input);
      border-radius: var(--radius-inner);
      padding: 6px 10px;
      cursor: pointer;
      color: var(--text-main);
    }
    .model-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }
    .model-card {
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-inner);
      padding: 12px 14px;
      background: var(--bg-panel);
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 160px;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s;
    }
    .model-card:hover {
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
      transform: translateY(-1px);
    }
    .model-card.active {
      border-color: var(--text-main);
      background: var(--bubble-user);
    }
    .model-card-title { font-weight: 700; color: var(--text-main); }
    .model-card-meta { font-size: 12px; color: var(--text-muted); }
    .model-card.empty {
      background: var(--bg-input);
      color: var(--text-muted);
      cursor: default;
    }
    .view-login .chat-interface { display: none !important; }
    .view-chat .login-modal { display: none !important; }

    /* Login flow states */
    .login-modal.state-connect .auth-section { display: none; }
    .login-modal.state-auth .conn-bar { display: none; }
    .markdown-body {
      font-size: 14px;
      position: relative;
    }
    .markdown-body code {
      background: rgba(0,0,0,0.05);
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 12px;
    }
    .markdown-body pre {
      background: transparent;
      color: inherit;
      padding: 0;
      border-radius: 0;
      overflow-x: visible;
      font-size: 12px;
    }
    .code-block-wrapper {
      position: relative;
      margin: 12px 0;
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-inner);
      background: var(--bg-panel);
      box-shadow: 0 6px 16px rgba(0,0,0,0.08);
    }
    .code-block-wrapper pre {
      margin: 0;
      padding: 12px 14px 14px;
      overflow-x: auto;
      border-radius: var(--radius-inner);
      background: transparent;
    }
    .copy-code-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 5px 9px;
      border: 1px solid var(--border-subtle);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.08);
      color: #e5e7eb;
      font-size: 11px;
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }
    .copy-code-btn:hover {
      background: rgba(255,255,255,0.16);
      border-color: #cbd5e1;
      color: #fff;
    }
    .copy-code-btn.copied {
      background: rgba(34,197,94,0.16);
      color: #34d399;
      border-color: rgba(34,197,94,0.4);
    }

    /* Sessions Sidebar */
    .chat-interface { display: flex; flex-direction: column; }
    .app-main { display: flex; flex-direction: row; gap: 0; align-items: stretch; }
    .sessions-sidebar {
      width: 260px; background: var(--bg-card);
      border-right: 1px solid var(--border-subtle);
      border-radius: var(--radius-card) 0 0 var(--radius-card);
      display: flex; flex-direction: column; gap: 14px; padding: 18px;
      transition: margin-left 0.3s ease, opacity 0.3s ease;
      max-height: calc(var(--vh, 1vh) * 100 - 150px); overflow: hidden;
      box-shadow: var(--shadow-card);
    }
    .sessions-sidebar.hidden {
      margin-left: -260px; opacity: 0; pointer-events: none;
    }
    .sidebar-header {
      display: flex; justify-content: space-between; align-items: center;
      padding-bottom: 8px; border-bottom: 1px solid var(--border-subtle);
    }
    .sidebar-title {
      font-size: 14px; font-weight: 700; text-transform: uppercase;
      letter-spacing: 0.08em; color: var(--text-main);
    }
    .sidebar-toggle-btn {
      background: transparent; border: 1px solid var(--border-subtle);
      border-radius: var(--radius-inner); padding: 6px 10px; cursor: pointer;
      font-size: 16px; line-height: 1; color: var(--text-main);
      transition: all 0.2s;
    }
    .sidebar-toggle-btn:hover {
      background: var(--accent-soft); border-color: var(--accent);
    }
    .new-chat-btn {
      width: 100%; background: var(--bg-input);
      border: 1px solid var(--border-subtle); border-radius: var(--radius-inner); padding: 10px 16px;
      font-size: 13px; font-weight: 600; color: var(--text-main);
      cursor: pointer; box-shadow: none;
      display: flex; align-items: center; justify-content: center; gap: 8px;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .new-chat-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(0,0,0,0.06);
    }
    .sessions-list {
      display: flex; flex-direction: column; gap: 6px;
      flex: 1; overflow-y: auto; min-height: 0;
      margin: -1rem; padding: 1rem;
    }
    .session-item {
      background: var(--bg-panel); border: 1px solid var(--border-subtle);
      border-radius: var(--radius-inner); padding: 12px 14px; cursor: pointer;
      transition: all 0.2s; display: flex; justify-content: space-between;
      align-items: center; gap: 8px;
      box-shadow: none;
    }
    .session-item:hover {
      background: var(--accent-soft);
      transform: translateY(1px);
    }
    .session-item.active {
      background: var(--bubble-user); border: 1px solid var(--border-subtle);
      box-shadow: none;
    }
    .session-item-content {
      flex: 1; min-width: 0;
    }
    .session-item-title {
      font-size: 13px; font-weight: 600; color: var(--text-main);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .session-item-meta {
      font-size: 10px; color: var(--text-muted);
      margin-top: 2px;
    }
    .session-item-delete {
      background: transparent; border: none; padding: 4px 8px;
      cursor: pointer; font-size: 16px; color: var(--text-muted);
      opacity: 0; transition: opacity 0.2s, color 0.2s;
      border-radius: var(--radius-inner);
    }
    .session-item:hover .session-item-delete {
      opacity: 1;
    }
    .session-item-delete:hover {
      color: #dc2626; background: var(--accent-soft);
    }
    .card {
      border-radius: 0 var(--radius-card) var(--radius-card) 0;
      max-height: calc(var(--vh, 1vh) * 100 - 150px); display: flex; flex-direction: column;
      overflow: hidden;
    }
    .sessions-sidebar.hidden + .card {
      border-radius: var(--radius-inner);
    }

    @media (max-width: 640px) {
      .app-main{
        padding:1rem;
      }
      .modal-content{
        padding:1rem;
      }
      .card { 
        background: unset;
        width: 100%;
        padding: unset;
        box-sizing: border-box;
        box-shadow: unset;
      }
      .chat-bubble { max-width: 100%; }
      .chat-messages{ padding: 16px; min-height: 200px;}
      .chat-textarea { min-height: 60px; }
      .conn-bar { flex-direction: column; align-items: stretch; }
      .sessions-sidebar { 
        width: calc(100% - 2rem);
        border-radius: var(--radius-inner)!important;position: absolute; z-index: 100; height: 100%; }
      .chat-interface.sidebar-hidden .chat-main-content {
        padding-left: 16px;
      }
      .hardware-panel {
        display: none;
      }
      .model-card{width:100%;}
      .session-bar {
        justify-content:flex-start;
      }
      .session-bar .model-metrics {
        order: 4;
        flex-direction: row;
        gap: 12px;
      }
      .session-hardware-inline {
        order: 5;
        display: flex;
        width: 100%;
      }
      .session-hardware-inline[data-gpu-available="false"] {
        display: none;
      }
      .session-hardware-bar {
        width: 100px;
        height: 4px;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script>window.hljs && hljs.highlightAll();</script>
  <script src="https://cdn.jsdelivr.net/npm/nkn-sdk@1.3.6/dist/nkn.min.js"></script>
  <script src="novio-sdk.js"></script>
</head>
<body class="view-login">
<div class="app-shell">

  <!-- Login Modal View -->
  <div class="login-modal modal-overlay state-connect">
    <div class="modal-content">
      <div class="modal-spinner" role="status" aria-live="polite" aria-label="Waiting for NKN relay connection"></div>
      <h1 class="modal-title">INFERENCE</h1>
      <p class="modal-subtitle" id="modal-subtitle">Connect to NKN relay to begin</p>

      <div class="conn-bar" id="conn-bar">
        <label for="pubkey-input">Relay Pubkey</label>
        <input id="pubkey-input" placeholder="64 hex characters" autocomplete="off">
        <label for="relay-address">Computed Address</label>
        <input id="relay-address" readonly>
        <label class="pushRight" for="novio-connect">Novio Wallet</label>
        <novio-connect id="novio-connect" useClient="true" useTls="false" useMessageEncryption="true" clientIdentifier="inference-web" size="medium"></novio-connect>
        <!--<button type="button" id="copy-address">Copy</button>-->
        <button type="button" id="nkn-connect" disabled>Connect</button>
        <button type="button" id="guest-connect" disabled style="background: transparent; color: var(--text-main);">Continue without wallet</button>
      </div>

      <div class="auth-section" id="auth-section">
        <div class="auth-forms">
          <form id="login-form" class="auth-card">
            <strong>Sign in to continue</strong>
            <label for="login-username">Username</label>
            <input id="login-username" autocomplete="username">
            <label for="login-password">Password</label>
            <input id="login-password" type="password" autocomplete="current-password">
            <button type="submit">Login</button>
            <button type="button" id="show-register" style="background: transparent; color: var(--text-muted); box-shadow: none; margin-top: 8px;">Need an account? Register</button>
          </form>
          <form id="register-form" class="auth-card hidden">
            <strong>Create new account</strong>
            <label for="register-username">Username</label>
            <input id="register-username" autocomplete="username">
            <label for="register-password">Password (min 6 chars)</label>
            <input id="register-password" type="password" autocomplete="new-password">
            <button type="submit">Register</button>
            <button type="button" id="show-login" style="background: transparent; color: var(--text-muted); box-shadow: none; margin-top: 8px;">Have an account? Login</button>
          </form>
        </div>
        <div class="status-log" id="activity-log">
          <div>Awaiting relay pubkey…</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Chat Interface View -->
  <div class="chat-interface">
    <header class="app-header">
      <div>
        <div class="app-header-title">INFER</div>
      </div>
      <div class="app-header-right">
          <span class="status-pill" id="nkn-status-chat">Connected</span>
      </div>
    </header>
    <main class="app-main">
      <!-- Sessions Sidebar -->
      <aside class="sessions-sidebar" id="sessions-sidebar">
        <div class="sidebar-header">
          <span class="sidebar-title">Chats</span>
          <button class="sidebar-toggle-btn" id="sidebar-toggle" title="Toggle sidebar">☰</button>
        </div>
        <button class="new-chat-btn" id="new-chat-btn">
          <span>+</span> New Chat
        </button>
        <div class="sessions-list" id="sessions-list">
          <!-- Sessions will be rendered here -->
        </div>
      </aside>

      <section class="card">
        <div class="session-bar">
          <button class="sidebar-inline-toggle" id="sidebar-toggle-inline" title="Show chats">☰</button>
          <span id="session-status">Not signed in.</span>
          <div class="model-status-wrapper">
            <span class="model-status-pill" id="model-status-pill" data-phase="idle">Model idle</span>
            <span class="model-spinner hidden" id="model-spinner" aria-hidden="true"></span>
          </div>
          <div class="model-metrics">
            <span id="model-latency">Latency · —</span>
            <span id="model-tps">TPS · —</span>
          </div>
          <div class="session-hardware-inline" id="session-hardware-inline" data-gpu-available="false" aria-hidden="true">
            <div class="session-hardware-bar">
              <span id="session-gpu-util-bar"></span>
            </div>
            <span id="session-gpu-util-label-small">—%</span>
          </div>
          <button type="button" class="theme-toggle" id="theme-toggle" title="Toggle theme">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3v2m0 14v2m9-9h-2M5 12H3m15.36 6.36l-1.42-1.42M6.06 6.06 4.64 4.64m12.72 0-1.42 1.42M6.06 17.94 4.64 19.36"/><circle cx="12" cy="12" r="4"/></svg>
            <span id="theme-toggle-label">Light</span>
          </button>
          <button type="button" id="logout-btn" aria-label="Log out">
            <svg width="18" height="18" viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/>
              <polyline points="16 17 21 12 16 7"/>
              <line x1="21" y1="12" x2="9" y2="12"/>
            </svg>
          </button>
        </div>
        <div class="hardware-panel" id="hardware-panel">
          <div class="hardware-row">
            <span>GPU Util</span>
            <div class="hardware-bar">
              <span id="gpu-util-bar"></span>
            </div>
            <span id="gpu-util-label">—%</span>
          </div>
          <div class="hardware-row">
            <span>GPU Memory</span>
            <span id="gpu-mem-label">— / — MB</span>
          </div>
          <div class="hardware-row">
            <span>Temp</span>
            <span id="gpu-temp-label">—°C</span>
          </div>
          <div class="hardware-row">
            <span>Status</span>
            <span id="hardware-status-label">Unknown</span>
          </div>
        </div>
        <div id="chat-area" class="chat-area">
          <div class="chat-messages" id="chat-messages"></div>
          <form id="chat-form" class="chat-input-wrap">
            <div class="chat-input-field">
              <input id="chat-input" type="text" class="chat-input-field-control" placeholder="Send a message to model" required autocomplete="off">
              <button class="btn chat-input-submit" type="submit" id="send-btn" aria-label="Send message">↗</button>
            </div>
            <div class="chat-tools" id="chat-tools">
              <div id="image-tool" class="tool images-tool hidden">
                <input type="file" id="image-input" accept="image/*" style="display:none">
                <button type="button" class="tool-btn" id="attach-image-btn">Attach image</button>
              <span class="chip hidden" id="image-chip">
                <span id="image-chip-label"></span>
                <button type="button" class="remove" id="remove-image-btn" aria-label="Remove image">×</button>
              </span>
            </div>
              <div id="tools-tool" class="tool tools-tool hidden">
                <button type="button" class="tool-btn" id="manage-tools-btn">Tools</button>
              <span class="chip hidden" id="tools-chip">
                <span id="tools-chip-label"></span>
              </span>
            </div>
            <label class="chip hidden thinking-chip" id="thinking-chip">
              <input type="checkbox" id="thinking-toggle" aria-label="Toggle thinking">
              <span class="thinking-label">Thinking</span>
            </label>
          </div>
          </form>
        </div>
      </section>
    </main>
  </div>
</div>
<div class="model-modal hidden" id="model-modal" role="dialog" aria-modal="true" aria-labelledby="model-modal-title">
  <div class="model-modal-content">
    <div class="model-modal-header">
      <div>
        <div class="model-modal-title" id="model-modal-title">Select a model</div>
        <p class="model-modal-sub" id="model-modal-sub">Choose a model for this chat</p>
      </div>
      <button class="model-modal-close" id="model-modal-close" aria-label="Close model picker">×</button>
    </div>
    <div class="model-grid" id="model-grid"></div>
  </div>
</div>
<div class="model-modal hidden" id="tools-modal" role="dialog" aria-modal="true" aria-labelledby="tools-modal-title">
  <div class="model-modal-content">
    <div class="model-modal-header">
      <div>
        <div class="model-modal-title" id="tools-modal-title">Tools</div>
        <p class="model-modal-sub" id="tools-modal-sub">Define tools to expose to this model</p>
      </div>
      <button class="model-modal-close" id="tools-modal-close" aria-label="Close tools modal">×</button>
    </div>
    <div class="tools-list" id="tools-list"></div>
    <form class="tool-form" id="tool-form">
      <div>
        <label for="tool-name">Name</label>
        <input id="tool-name" placeholder="get_weather" required>
      </div>
      <div>
        <label for="tool-desc">Description</label>
        <input id="tool-desc" placeholder="Describe what the tool does" required>
      </div>
      <div>
        <label for="tool-schema">Parameters JSON (Ollama tool schema)</label>
        <textarea id="tool-schema" spellcheck="false" placeholder='{\"type\":\"object\",\"properties\":{\"location\":{\"type\":\"string\"}},\"required\":[\"location\"]}' required></textarea>
        <div class="tool-form-hint">Must be valid JSON Schema object and will be sent as <code>function.parameters</code>.</div>
      </div>
      <div class="tool-actions-inline">
        <button type="submit">Add/Update tool</button>
        <div class="tool-error hidden" id="tool-error"></div>
      </div>
    </form>
  </div>
</div>
<script>
disableZoomGestures();

function disableZoomGestures(){
  const prevent = (event) => event.preventDefault();
  ['gesturestart', 'gesturechange'].forEach((type) => {
    document.addEventListener(type, prevent, { passive: false });
  });
  document.addEventListener('touchmove', (event) => {
    if (event.touches.length > 1 || (event.scale && event.scale !== 1)) {
      event.preventDefault();
    }
  }, { passive: false });
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (event) => {
    const now = Date.now();
    if (event.touches.length === 0 && now - lastTouchEnd < 350) {
      event.preventDefault();
    }
    lastTouchEnd = now;
  }, { passive: false });
}

const AUTO_LOGIN_KEY = 'inference.autologin';
const LEGACY_AUTO_LOGIN_KEY = 'loving.autologin';
const STORAGE_KEYS = {
  pubkey: 'inference.pubkey',
  legacyPubkey: 'loving.pubkey',
  seed: 'inference.nkn.seed',
  legacySeed: 'loving.nkn.seed',
  modelCaps: 'inference.model.capabilities',
  thumbs: 'inference.message.thumbs',
  theme: 'inference.theme',
};

// Parse URL parameter for relay server endpoint
function parseRelayFromURL(){
  const urlParams = new URLSearchParams(window.location.search);
  const serverParam = urlParams.get('server');
  if (serverParam && /^[0-9a-f]{64}$/i.test(serverParam)){
    const normalized = serverParam.toLowerCase();
    localStorage.setItem(STORAGE_KEYS.pubkey, normalized);
    localStorage.removeItem(STORAGE_KEYS.legacyPubkey);
    console.log('[init] Relay pubkey loaded from URL parameter');
    return normalized;
  }
  return null;
}

// Check URL parameter first, fallback to localStorage
const urlRelay = parseRelayFromURL();

const state = {
  relayPubkey: urlRelay || localStorage.getItem(STORAGE_KEYS.pubkey) || localStorage.getItem(STORAGE_KEYS.legacyPubkey) || '',
  relay: '',
  relayVerified: false,
  relayInfo: null,
  session: null,
  currentSessionId: null,
  sessions: [],
  messages: [],
  selectedModel: null,
  availableModels: [],
  currentCapabilities: { supports_images: false, supports_thinking: false, supports_tools: false },
  modelCapsCache: new Map(),
  thumbsCache: new Map(),
  theme: 'light',
  userPreferences: {},
  tools: [],
  pendingImage: null,
  thinkingEnabled: false,
  uploadStatuses: new Map(),
  uploadToAssistant: new Map(),
  uploadJobs: new Map(),
  uploadGuards: new Map(),
  busy: false,
  pendingSend: false,
  nkn: {
    seed: null,
    client: null,
    ready: false,
    pending: new Map(),
    pendingCounter: 0,
    connectPromise: null,
    addr: '',
    reconnectTimer: null,
    backoffMs: 1000,
    baseBackoffMs: 1000,
    maxBackoffMs: 20000,
    healthInterval: null,
    healthFailures: 0,
    transport: 'auto',
    forceDirect: false,
  },
  novio: {
    ready: false,
  },
  autoLoginTried: false,
  autoLoginInProgress: false,
  savedCreds: null,
  modelStatus: { phase: 'idle', description: 'Model idle', meta: {} },
};

state.nkn.seed = getOrCreateSeed();
state.savedCreds = loadSavedCreds();

let novioClient = null;

const els = {
  loginModal: document.querySelector('.login-modal'),
  modalSubtitle: document.getElementById('modal-subtitle'),
  pubkeyInput: document.getElementById('pubkey-input'),
  relayAddress: document.getElementById('relay-address'),
  copyAddress: document.getElementById('copy-address'),
  connectBtn: document.getElementById('nkn-connect'),
  guestConnectBtn: document.getElementById('guest-connect'),
  novioConnect: document.getElementById('novio-connect'),
  nknStatusChat: document.getElementById('nkn-status-chat'),
  connBar: document.getElementById('conn-bar'),
  authSection: document.getElementById('auth-section'),
  chatArea: document.getElementById('chat-area'),
  chatInterface: document.querySelector('.chat-interface'),
  modelStatusPill: document.getElementById('model-status-pill'),
  modelSpinner: document.getElementById('model-spinner'),
  modelLatency: document.getElementById('model-latency'),
  modelTps: document.getElementById('model-tps'),
  modelModal: document.getElementById('model-modal'),
  modelGrid: document.getElementById('model-grid'),
  modelModalClose: document.getElementById('model-modal-close'),
  modelModalSub: document.getElementById('model-modal-sub'),
  imageTool: document.getElementById('image-tool'),
  attachImageBtn: document.getElementById('attach-image-btn'),
  imageInput: document.getElementById('image-input'),
  imageChip: document.getElementById('image-chip'),
  imageChipLabel: document.getElementById('image-chip-label'),
  removeImageBtn: document.getElementById('remove-image-btn'),
  toolsTool: document.getElementById('tools-tool'),
  manageToolsBtn: document.getElementById('manage-tools-btn'),
  toolsChip: document.getElementById('tools-chip'),
  toolsChipLabel: document.getElementById('tools-chip-label'),
  toolsModal: document.getElementById('tools-modal'),
  toolsModalClose: document.getElementById('tools-modal-close'),
  toolsModalSub: document.getElementById('tools-modal-sub'),
  toolsList: document.getElementById('tools-list'),
  toolForm: document.getElementById('tool-form'),
  toolNameInput: document.getElementById('tool-name'),
  toolDescInput: document.getElementById('tool-desc'),
  toolSchemaInput: document.getElementById('tool-schema'),
  toolError: document.getElementById('tool-error'),
  thinkingToggle: document.getElementById('thinking-toggle'),
  thinkingChip: document.getElementById('thinking-chip'),
  sessionsSidebar: document.getElementById('sessions-sidebar'),
  sidebarToggle: document.getElementById('sidebar-toggle'),
  sidebarInlineToggle: document.getElementById('sidebar-toggle-inline'),
  newChatBtn: document.getElementById('new-chat-btn'),
  sessionsList: document.getElementById('sessions-list'),
  registerForm: document.getElementById('register-form'),
  registerUser: document.getElementById('register-username'),
  registerPass: document.getElementById('register-password'),
  loginForm: document.getElementById('login-form'),
  loginUser: document.getElementById('login-username'),
  loginPass: document.getElementById('login-password'),
  showRegisterBtn: document.getElementById('show-register'),
  showLoginBtn: document.getElementById('show-login'),
  logoutBtn: document.getElementById('logout-btn'),
  sessionStatus: document.getElementById('session-status'),
  activity: document.getElementById('activity-log'),
  hardwarePanel: document.getElementById('hardware-panel'),
  gpuUtilBar: document.getElementById('gpu-util-bar'),
  gpuUtilLabel: document.getElementById('gpu-util-label'),
  gpuMemLabel: document.getElementById('gpu-mem-label'),
  gpuTempLabel: document.getElementById('gpu-temp-label'),
  hardwareStatusLabel: document.getElementById('hardware-status-label'),
  chat: document.getElementById('chat-messages'),
  input: document.getElementById('chat-input'),
  form: document.getElementById('chat-form'),
  sendBtn: document.getElementById('send-btn'),
  sessionHardwareInline: document.getElementById('session-hardware-inline'),
  sessionGpuUtilBarInline: document.getElementById('session-gpu-util-bar'),
  sessionGpuUtilLabelInline: document.getElementById('session-gpu-util-label-small'),
  themeToggle: document.getElementById('theme-toggle'),
  themeToggleLabel: document.getElementById('theme-toggle-label'),
  scrollResumeBtn: null,
};
const AUTO_SCROLL_THRESHOLD_PX = 120;
let autoScrollEnabled = true;

loadCachedModelCaps();
loadCachedThumbs();
applyTheme(loadStoredTheme());

function getCurrentSession(){
  return state.sessions.find((s) => s.id === state.currentSessionId) || null;
}

function loadCachedModelCaps(){
  try {
    const raw = localStorage.getItem(STORAGE_KEYS.modelCaps);
    if (!raw) return;
    const parsed = JSON.parse(raw);
    if (parsed && typeof parsed === 'object'){
      Object.entries(parsed).forEach(([name, caps]) => {
        if (name && caps) state.modelCapsCache.set(name, caps);
      });
    }
  } catch (_) {}
}

function persistCachedModelCaps(){
  const obj = {};
  state.modelCapsCache.forEach((caps, name) => {
    obj[name] = caps;
  });
  try {
    localStorage.setItem(STORAGE_KEYS.modelCaps, JSON.stringify(obj));
  } catch (_) {}
}

function loadCachedThumbs(){
  try {
    const raw = localStorage.getItem(STORAGE_KEYS.thumbs);
    if (!raw) return;
    const parsed = JSON.parse(raw);
    if (parsed && typeof parsed === 'object'){
      Object.entries(parsed).forEach(([id, dataUrl]) => {
        if (id && dataUrl) state.thumbsCache.set(id, dataUrl);
      });
    }
  } catch (_) {}
}

function persistCachedThumbs(){
  const obj = {};
  state.thumbsCache.forEach((dataUrl, id) => {
    obj[id] = dataUrl;
  });
  try {
    localStorage.setItem(STORAGE_KEYS.thumbs, JSON.stringify(obj));
  } catch (_) {}
}

function cacheThumb(messageId, dataUrl){
  if (!messageId || !dataUrl) return;
  state.thumbsCache.set(messageId, dataUrl);
  persistCachedThumbs();
}

function getCachedThumb(messageId){
  if (!messageId) return null;
  return state.thumbsCache.get(messageId) || null;
}

function loadStoredTheme(){
  const stored = localStorage.getItem(STORAGE_KEYS.theme);
  if (stored === 'dark' || stored === 'light') {
    state.theme = stored;
  }
  return state.theme;
}

function applyTheme(theme){
  const desired = theme === 'dark' ? 'dark' : 'light';
  state.theme = desired;
  if (desired === 'dark'){
    document.body.classList.add('theme-dark');
  } else {
    document.body.classList.remove('theme-dark');
  }
  const label = els.themeToggleLabel;
  if (label) label.textContent = desired === 'dark' ? 'Dark' : 'Light';
  if (!state.userPreferences) state.userPreferences = {};
  state.userPreferences.theme = desired;
  try { localStorage.setItem(STORAGE_KEYS.theme, desired); } catch (_) {}
}

async function saveUserPreferences() {
  if (!state.session || !state.session.username) return;
  if (!state.userPreferences) state.userPreferences = {};
  state.userPreferences.tools = state.tools || [];
  try {
    await nknSendRequestWithRetry({ event: 'user.prefs.set', preferences: state.userPreferences || {} });
  } catch (err){
    console.warn('Failed to persist preferences', err);
  }
}

async function fetchUserPreferences() {
  if (!state.session) return {};
  try {
    const resp = await nknSendRequestWithRetry({ event: 'user.prefs.get' });
    const prefs = (resp && typeof resp.preferences === 'object') ? resp.preferences : {};
    state.userPreferences = prefs;
    if (prefs.theme) applyTheme(prefs.theme);
    state.tools = Array.isArray(prefs.tools) ? prefs.tools : [];
    updateToolsChip();
    return prefs;
  } catch (err){
    console.warn('Failed to load preferences', err);
    return {};
  }
}

function getCapabilitiesForModel(modelName){
  if (!modelName) return { supports_images: false, supports_thinking: false, supports_tools: false };
  const target = (state.availableModels || []).find((m) => m.name === modelName);
  if (target && target.capabilities){
    state.modelCapsCache.set(modelName, target.capabilities);
    persistCachedModelCaps();
    return target.capabilities;
  }
  const cached = state.modelCapsCache.get(modelName);
  if (cached) return cached;
  const inferred = inferCapabilitiesFromNameFrontend(modelName);
  state.modelCapsCache.set(modelName, inferred);
  persistCachedModelCaps();
  return inferred;
}

function getModelLabel(){
  const current = getCurrentSession();
  if (current && current.model) return current.model;
  if (state.selectedModel) return state.selectedModel;
  if (state.relayInfo && state.relayInfo.model) return state.relayInfo.model;
  return 'model';
}

function updateChatPlaceholder(){
  if (!els.input) return;
  const modelLabel = getModelLabel();
  els.input.placeholder = `Send a message to ${modelLabel}`;
}

function updateModelDisplay(descriptionOverride){
  const modelLabel = getModelLabel();
  const description = descriptionOverride || (state.modelStatus && state.modelStatus.description) || '';
  if (els.modelStatusPill){
    const parts = [modelLabel];
    if (description) parts.push(description);
    els.modelStatusPill.textContent = parts.join(' · ');
    els.modelStatusPill.setAttribute('aria-label', `Current model ${modelLabel}. Click to change.`);
  }
  updateChatPlaceholder();
}

function syncCurrentModelFromState(modelHint){
  if (modelHint) state.selectedModel = modelHint;
  const current = getCurrentSession();
  if (current && current.model){
    state.selectedModel = current.model;
  } else if (!state.selectedModel && state.relayInfo && state.relayInfo.model){
    state.selectedModel = state.relayInfo.model;
  }
  const caps = getCapabilitiesForModel(state.selectedModel);
  // If cache/heuristics say images are supported, trust it on load
  state.currentCapabilities = caps;
  forceImageCapabilityFromSelectedModel();
  updateToolVisibility();
  updateModelDisplay();
}

updateModelDisplay();

function inferCapabilitiesFromNameFrontend(name){
  const lowered = (name || '').toLowerCase();
  const supportsImages = ['vision', 'vl', 'clip', 'llava', 'vmodel', 'gpt-4o', 'vision-', 'mm', 'multimodal', 'moondream', 'idefics', 'qwen-vl'].some(k => lowered.includes(k));
  const supportsThinking = ['think', 'deepseek', 'reason', 'qwen2.5', 'qwen2.5-thinking', 'thinking'].some(k => lowered.includes(k));
  const supportsTools = ['tool', 'function', 'function_call', 'function-call', 'functions'].some(k => lowered.includes(k));
  return { supports_images: supportsImages, supports_thinking: supportsThinking, supports_tools: supportsTools };
}

async function fetchAvailableModels(){
  if (!state.session) {
    toast('Sign in to load models', false);
    return [];
  }
  if (els.modelGrid) {
    els.modelGrid.innerHTML = '<div class="model-card empty">Loading models…</div>';
  }
  try {
    const resp = await nknSendRequestWithRetry({ event: 'models.list' });
    const raw = Array.isArray(resp.models) ? resp.models : [];
    state.availableModels = raw
      .map((m) => {
        const entry = (typeof m === 'string' ? { name: m } : m) || {};
        const detailsCaps = Array.isArray(entry.details?.capabilities) ? entry.details.capabilities : [];
        const mergedCaps = entry.capabilities || {};
        entry.capabilities = {
          supports_images: Boolean(mergedCaps.supports_images) || detailsCaps.some(c => typeof c === 'string' && /vision|image|multimodal|vl|mm/i.test(c)),
          supports_thinking: Boolean(mergedCaps.supports_thinking) || detailsCaps.some(c => typeof c === 'string' && /think|reason|monologue/i.test(c)),
          supports_tools: Boolean(mergedCaps.supports_tools) || detailsCaps.some(c => typeof c === 'string' && /tool|function/i.test(c)),
        };
        // Fallback heuristics if still false
        const inferred = inferCapabilitiesFromNameFrontend(entry.name);
        entry.capabilities.supports_images = entry.capabilities.supports_images || inferred.supports_images;
        entry.capabilities.supports_thinking = entry.capabilities.supports_thinking || inferred.supports_thinking;
        entry.capabilities.supports_tools = entry.capabilities.supports_tools || inferred.supports_tools;
        if (entry.name) state.modelCapsCache.set(entry.name, entry.capabilities);
        return entry;
      })
      .filter((m) => m && m.name);
    persistCachedModelCaps();
    renderModelOptions();
    state.currentCapabilities = getCapabilitiesForModel(getModelLabel());
    forceImageCapabilityFromSelectedModel();
    updateToolVisibility();
    return state.availableModels;
  } catch (err) {
    console.warn('Failed to load models', err);
    if (els.modelGrid) {
      els.modelGrid.innerHTML = '<div class="model-card empty">Unable to load models.</div>';
    }
    toast(err.message || 'Unable to load models', false);
    return [];
  }
}

function renderModelOptions(){
  if (!els.modelGrid) return;
  const current = getModelLabel();
  if (!state.availableModels.length){
    els.modelGrid.innerHTML = '<div class="model-card empty">No models available.</div>';
    return;
  }
  els.modelGrid.innerHTML = state.availableModels.map((model) => {
    const name = model.name || '';
    const meta = model.details && model.details.details ? model.details.details : (model.details || {});
    const size = meta && meta.size ? meta.size : '';
    const metaText = size ? String(size) : 'Click to use for this chat';
    const active = name === current ? 'active' : '';
    const capBadges = formatCapabilityBadges(model.capabilities);
    return `
      <button type="button" class="model-card ${active}" data-model="${name}" data-supports-images="${model.capabilities?.supports_images ? '1' : '0'}">
        <div class="model-card-title">${name}</div>
        <div class="model-card-meta">${metaText}</div>
        <div class="model-card-meta">${capBadges}</div>
      </button>
    `;
  }).join('');

  // If current model card advertises images, ensure capability is set before visibility update
  const activeCard = els.modelGrid.querySelector('.model-card.active');
  if (activeCard && activeCard.dataset.supportsImages === '1'){
    state.currentCapabilities.supports_images = true;
  }
  updateToolVisibility();

  els.modelGrid.querySelectorAll('.model-card').forEach((card) => {
    const targetModel = card.dataset.model;
    if (!targetModel) return;
    card.addEventListener('click', () => handleModelSelect(targetModel));
  });
}

function openModelModal(){
  if (!els.modelModal) return;
  if (!state.session){
    toast('Sign in first', false);
    return;
  }
  syncCurrentModelFromState();
  updateModelModalSub();
  if (!state.availableModels.length){
    fetchAvailableModels().then(() => {
      if (els.modelModal) els.modelModal.classList.remove('hidden');
    });
  } else {
    renderModelOptions();
    els.modelModal.classList.remove('hidden');
  }
}

function closeModelModal(){
  if (els.modelModal) els.modelModal.classList.add('hidden');
}

function updateModelModalSub(){
  if (!els.modelModalSub) return;
  els.modelModalSub.textContent = `Currently using ${getModelLabel()} for this chat`;
}

async function handleModelSelect(modelName){
  try {
    const card = document.querySelector(`.model-card[data-model="${modelName}"]`);
    const supportsImages = card ? card.dataset.supportsImages === '1' : false;
    await setSessionModel(modelName);
    state.currentCapabilities = getCapabilitiesForModel(modelName);
    if (supportsImages) {
      state.currentCapabilities.supports_images = true;
    }
    persistCachedModelCaps();
    updateToolVisibility();
    closeModelModal();
  } catch (err) {
    toast(err.message || 'Unable to set model', false);
  }
}

function renderToolsList(){
  if (!els.toolsList) return;
  const tools = getActiveTools();
  if (!tools.length){
    els.toolsList.innerHTML = '<div class="model-card empty">No tools defined. Add one below.</div>';
    return;
  }
  els.toolsList.innerHTML = tools.map((tool, idx) => {
    const fn = tool.function || {};
    const paramsPreview = (() => {
      try {
        return JSON.stringify(fn.parameters || {}, null, 0).slice(0, 120);
      } catch {
        return '';
      }
    })();
    return `
      <div class="tool-row" data-index="${idx}">
        <div class="tool-meta">
          <div class="tool-title">${escapeHtml(fn.name || '')}</div>
          <div class="tool-desc">${escapeHtml(fn.description || '')}</div>
          <div class="tool-desc"><code>parameters</code>: ${escapeHtml(paramsPreview)}</div>
        </div>
        <div class="tool-actions">
          <button type="button" data-action="edit" data-index="${idx}">Edit</button>
          <button type="button" data-action="delete" data-index="${idx}">Delete</button>
        </div>
      </div>
    `;
  }).join('');

  els.toolsList.querySelectorAll('button[data-action="edit"]').forEach((btn) => {
    btn.addEventListener('click', () => {
      const idx = Number(btn.dataset.index);
      const toolsArr = getActiveTools();
      const target = toolsArr[idx];
      if (!target) return;
      const fn = target.function || {};
      if (els.toolNameInput) els.toolNameInput.value = fn.name || '';
      if (els.toolDescInput) els.toolDescInput.value = fn.description || '';
      if (els.toolSchemaInput) {
        try {
          els.toolSchemaInput.value = JSON.stringify(fn.parameters || {}, null, 2);
        } catch {
          els.toolSchemaInput.value = '';
        }
      }
      if (els.toolsModal) els.toolsModal.scrollTop = 0;
    });
  });

  els.toolsList.querySelectorAll('button[data-action="delete"]').forEach((btn) => {
    btn.addEventListener('click', () => {
      const idx = Number(btn.dataset.index);
      const toolsArr = Array.isArray(state.tools) ? [...state.tools] : [];
      toolsArr.splice(idx, 1);
      state.tools = toolsArr;
      updateToolsChip();
      saveUserPreferences();
      renderToolsList();
    });
  });
}

function openToolsModal(){
  if (!els.toolsModal) return;
  if (!state.session){
    toast('Sign in first', false);
    return;
  }
  if (!state.currentCapabilities.supports_tools){
    toast('Current model does not support tools', false);
    return;
  }
  renderToolsList();
  if (els.toolsModalSub) els.toolsModalSub.textContent = `Tools for ${getModelLabel()}`;
  els.toolsModal.classList.remove('hidden');
}

function closeToolsModal(){
  if (els.toolsModal) els.toolsModal.classList.add('hidden');
  if (els.toolError) els.toolError.classList.add('hidden');
}

function handleToolSubmit(event){
  event.preventDefault();
  if (els.toolError) els.toolError.classList.add('hidden');
  const name = (els.toolNameInput?.value || '').trim();
  const description = (els.toolDescInput?.value || '').trim();
  const schemaRaw = (els.toolSchemaInput?.value || '').trim();
  if (!name || !schemaRaw){
    if (els.toolError){
      els.toolError.textContent = 'Name and parameters are required.';
      els.toolError.classList.remove('hidden');
    }
    return;
  }
  let paramsObj = {};
  try {
    paramsObj = JSON.parse(schemaRaw);
    if (typeof paramsObj !== 'object' || paramsObj === null || Array.isArray(paramsObj)){
      throw new Error('Parameters must be a JSON object');
    }
  } catch (err){
    if (els.toolError){
      els.toolError.textContent = err.message || 'Parameters must be valid JSON';
      els.toolError.classList.remove('hidden');
    }
    return;
  }
  const definition = {
    type: 'function',
    function: {
      name,
      description,
      parameters: paramsObj,
    },
  };
  const toolsArr = Array.isArray(state.tools) ? [...state.tools] : [];
  const existingIdx = toolsArr.findIndex((t) => t && t.function && t.function.name === name);
  if (existingIdx >= 0){
    toolsArr[existingIdx] = definition;
  } else {
    toolsArr.push(definition);
  }
  state.tools = toolsArr;
  updateToolsChip();
  renderToolsList();
  saveUserPreferences();
  toast(`Saved tool ${name}`);
}

async function setSessionModel(modelName){
  if (!state.session || !state.currentSessionId) {
    toast('Sign in first', false);
    return;
  }
  const resp = await nknSendRequestWithRetry({ event: 'session.model.set', session_id: state.currentSessionId, model: modelName });
  if (resp.sessions) state.sessions = resp.sessions;
  if (resp.current_session_id) state.currentSessionId = resp.current_session_id;
  state.selectedModel = modelName;
  syncCurrentModelFromState(resp.current_session_model || modelName);
  renderSessions();
  updateModelDisplay();
  toast(`Model set to ${modelName}`);
}

function toast(text, ok=true){
  if (els.nknStatusChat) {
    els.nknStatusChat.textContent = text;
    els.nknStatusChat.className = 'status-pill ' + (ok ? 'ok' : 'err');
  }
  logActivity(text, ok);
}

function switchToView(viewName){
  document.body.className = `view-${viewName}`;
}

function showLoginForm(){
  els.loginForm.classList.remove('hidden');
  els.registerForm.classList.add('hidden');
}

function showRegisterForm(){
  els.registerForm.classList.remove('hidden');
  els.loginForm.classList.add('hidden');
}

function getOrCreateSeed(){
  let existing = localStorage.getItem(STORAGE_KEYS.seed);
  if (!existing || !/^[0-9a-f]{64}$/i.test(existing)){
    existing = localStorage.getItem(STORAGE_KEYS.legacySeed);
  }
  if (existing && /^[0-9a-f]{64}$/i.test(existing)){
    const normalized = existing.toLowerCase();
    if (existing !== normalized){
      localStorage.setItem(STORAGE_KEYS.seed, normalized);
    }
    localStorage.removeItem(STORAGE_KEYS.legacySeed);
    return normalized;
  }
  const arr = new Uint8Array(32);
  window.crypto.getRandomValues(arr);
  const hex = Array.from(arr, (b) => b.toString(16).padStart(2, '0')).join('');
  localStorage.setItem(STORAGE_KEYS.seed, hex);
  return hex;
}

function loadSavedCreds(){
  try {
    const raw = localStorage.getItem(AUTO_LOGIN_KEY) || localStorage.getItem(LEGACY_AUTO_LOGIN_KEY);
    if (!raw) return null;
    const data = JSON.parse(raw);
    if (data && data.username && data.password){
      return { username: String(data.username), password: String(data.password) };
    }
  } catch (err){
    console.warn('Failed to load auto-login creds', err);
  }
  return null;
}

function isInvalidCredentialsError(err){
  if (!err) return false;
  const msg = (err && err.message ? String(err.message) : String(err)).toLowerCase();
  return msg.includes('invalid credentials') || msg.includes('invalid username') || msg.includes('invalid password');
}

function saveCredentials(username, password){
  if (!username || !password) return;
  try {
    localStorage.setItem(
      AUTO_LOGIN_KEY,
      JSON.stringify({ username, password })
    );
    localStorage.removeItem(LEGACY_AUTO_LOGIN_KEY);
    state.savedCreds = { username, password };
    prefillSavedCreds();
  } catch (err){
    console.warn('Failed to save creds', err);
  }
}

function prefillSavedCreds(){
  if (!els) return;
  if (state.savedCreds){
    els.loginUser.value = state.savedCreds.username || '';
    els.loginPass.value = state.savedCreds.password || '';
    return;
  }
  if (els.loginUser) els.loginUser.value = '';
  if (els.loginPass) els.loginPass.value = '';
}

function bindChatInputEvents(){
  if (!els.input) return;
  els.input.removeEventListener('input', handleChatInputInputEvent);
  els.input.removeEventListener('keydown', handleChatInputKeydownEvent);
  els.input.removeEventListener('blur', handleChatInputBlurEvent);
  els.input.removeEventListener('focus', handleChatInputFocusEvent);
  els.input.addEventListener('input', handleChatInputInputEvent);
  els.input.addEventListener('keydown', handleChatInputKeydownEvent);
  els.input.addEventListener('blur', handleChatInputBlurEvent);
  els.input.addEventListener('focus', handleChatInputFocusEvent);
  checkExpandInputOverflow();
}

function handleChatInputInputEvent(){
  const input = els.input;
  if (!input) return;
  if (isMobileViewport()){
    if (input.tagName.toLowerCase() === 'textarea'){
      downgradeChatInputToInput();
    }
    return;
  }
  if (input.tagName.toLowerCase() === 'input'){
    checkExpandInputOverflow();
  } else {
    maybeDowngradeTextarea();
  }
}

function handleChatInputKeydownEvent(event){
  if (isMobileViewport()) return;
  if (!els.input) return;
  const isTextarea = els.input.tagName.toLowerCase() === 'textarea';
  const isInput = !isTextarea;
  if (isInput && (event.ctrlKey || event.metaKey) && event.key === 'Enter'){
    event.preventDefault();
    upgradeChatInputToTextarea({ addNewline: true });
  } else if (isTextarea && (event.ctrlKey || event.metaKey) && event.key === 'Enter'){
    event.preventDefault();
    if (els.form){
      if (typeof els.form.requestSubmit === 'function'){
        els.form.requestSubmit(els.sendBtn || undefined);
      } else {
        const submitEvent = new Event('submit', { cancelable: true, bubbles: true });
        els.form.dispatchEvent(submitEvent);
      }
    }
  } else if (isTextarea && event.key === 'Backspace'){
    // After the key event, see if we can shrink back to input
    setTimeout(() => maybeDowngradeTextarea(), 0);
  }
}

function handleChatInputBlurEvent(){
  const input = els.input;
  if (!input || input.tagName.toLowerCase() !== 'textarea') return;
  // Reset height so it collapses to the base input size when unfocused
  input.style.height = '';
}

function handleChatInputFocusEvent(){
  const input = els.input;
  if (!input || input.tagName.toLowerCase() !== 'textarea') return;
  adjustTextareaHeight(input);
}

function checkExpandInputOverflow(){
  if (isMobileViewport()) return;
  const input = els.input;
  if (!input || input.tagName.toLowerCase() !== 'input') return;
  if (!input.value) return;
  if (input.scrollWidth > input.clientWidth + 20){
    upgradeChatInputToTextarea();
  }
}

function upgradeChatInputToTextarea({ addNewline = false } = {}){
  if (isMobileViewport()) return;
  const input = els.input;
  if (!input || input.tagName.toLowerCase() === 'textarea') return;
  const wrapper = document.querySelector('.chat-input-field');
  if (!wrapper) return;
  const value = input.value || '';
  const textarea = document.createElement('textarea');
  textarea.id = 'chat-input';
  textarea.className = `${input.className} multiline`;
  textarea.placeholder = input.placeholder || '';
  textarea.autocomplete = input.autocomplete;
  textarea.spellcheck = input.spellcheck;
  textarea.required = input.required;
  textarea.rows = 3;
  textarea.value = value + (addNewline ? '\n' : '');
  wrapper.replaceChild(textarea, input);
  els.input = textarea;
  bindChatInputEvents();
  adjustTextareaHeight(textarea);
  textarea.focus();
  textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
}

function downgradeChatInputToInput(){
  const textarea = els.input;
  if (!textarea || textarea.tagName.toLowerCase() === 'input') return;
  const wrapper = document.querySelector('.chat-input-field');
  if (!wrapper) return;
  const value = textarea.value || '';
  const input = document.createElement('input');
  input.id = 'chat-input';
  input.type = 'text';
  input.className = textarea.className.replace(/\bmultiline\b/g, '').trim();
  input.placeholder = textarea.placeholder || '';
  input.autocomplete = textarea.autocomplete;
  input.spellcheck = textarea.spellcheck;
  input.required = textarea.required;
  input.value = value;
  wrapper.replaceChild(input, textarea);
  els.input = input;
  bindChatInputEvents();
  input.focus();
  input.selectionStart = input.selectionEnd = input.value.length;
}

function maybeDowngradeTextarea(){
  const textarea = els.input;
  if (!textarea || textarea.tagName.toLowerCase() !== 'textarea') return;
  if (shouldDowngradeTextarea(textarea)){
    downgradeChatInputToInput();
    return;
  }
  adjustTextareaHeight(textarea);
}

function shouldDowngradeTextarea(textarea){
  if (!textarea || textarea.tagName.toLowerCase() !== 'textarea') return false;
  const value = textarea.value || '';
  if (value.includes('\n')) return false;
  const style = window.getComputedStyle(textarea);
  const lineHeight = parseFloat(style.lineHeight) || 20;
  const paddingTop = parseFloat(style.paddingTop) || 0;
  const paddingBottom = parseFloat(style.paddingBottom) || 0;
  const innerHeight = textarea.scrollHeight - paddingTop - paddingBottom;
  const fitsWithoutWrapping = textarea.scrollWidth <= textarea.clientWidth + 4;
  return innerHeight <= lineHeight * 1.5 && fitsWithoutWrapping;
}

function adjustTextareaHeight(textarea){
  textarea.style.height = 'auto';
  textarea.style.height = `${textarea.scrollHeight}px`;
}

function isChatNearBottom(threshold = AUTO_SCROLL_THRESHOLD_PX){
  if (!els.chat) return true;
  const distance = els.chat.scrollHeight - els.chat.clientHeight - els.chat.scrollTop;
  return distance <= threshold;
}

function scrollChatToBottom(force = false){
  if (!els.chat) return;
  if (!force && !autoScrollEnabled) {
    updateScrollButtonVisibility();
    return;
  }
  els.chat.scrollTop = els.chat.scrollHeight;
  if (force) autoScrollEnabled = true;
  updateScrollButtonVisibility();
}

function updateScrollButtonVisibility(){
  if (!els.scrollResumeBtn) return;
  const shouldShow = !autoScrollEnabled;
  els.scrollResumeBtn.classList.toggle('hidden', !shouldShow);
}

function ensureChatScrollButton(){
  if (els.scrollResumeBtn || !els.chat) return;
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'scroll-resume-btn hidden';
  btn.textContent = 'Jump to latest';
  btn.addEventListener('click', () => {
    autoScrollEnabled = true;
    scrollChatToBottom(true);
  });
  els.scrollResumeBtn = btn;
  els.chat.appendChild(btn);
}

function handleChatScroll(){
  if (!els.chat) return;
  if (isChatNearBottom(AUTO_SCROLL_THRESHOLD_PX / 2)){
    autoScrollEnabled = true;
  } else {
    autoScrollEnabled = false;
  }
  updateScrollButtonVisibility();
}

function setupChatScrollHandling(){
  ensureChatScrollButton();
  if (els.chat){
    els.chat.addEventListener('scroll', handleChatScroll);
  }
}

function logActivity(text, ok=true){
  if (!els.activity) return;
  const line = document.createElement('div');
  line.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
  line.className = ok ? 'ok' : 'err';
  els.activity.prepend(line);
  const items = Array.from(els.activity.children);
  items.slice(20).forEach((node) => node.remove());
}

function usingNovioTransport(){
  return state.nkn.transport === 'novio';
}

function preferNovioTransport(){
  if (state.nkn.forceDirect) return false;
  return !!(novioClient && window.novio && window.novio.isInstalled && (window.novio.isConnected || state.novio.ready));
}

function shouldRetryNknError(err){
  const msg = String(err && err.message || err || '').toLowerCase();
  return msg.includes('message timeout') || msg.includes('failed to send') || msg.includes('timeout') || msg.includes("readystate is not") || msg.includes('rtcdatachannel');
}

function resetNknClient(){
  try {
    if (!usingNovioTransport() && state.nkn.client && state.nkn.client.close) state.nkn.client.close();
  } catch (_) {
    // ignore
  }
  state.nkn.client = null;
  state.nkn.ready = false;
  state.nkn.healthFailures = 0;
  state.nkn.addr = '';
  state.nkn.connectPromise = null;
  if (!usingNovioTransport()){
    scheduleNknReconnect('reset');
  }
}

function scheduleNknReconnect(reason){
  if (usingNovioTransport()) return;
  if (state.nkn.reconnectTimer) return;
  const delay = state.nkn.backoffMs = Math.min(state.nkn.backoffMs * 1.5, state.nkn.maxBackoffMs);
  logActivity(`NKN reconnect scheduled (${reason}) in ${(delay/1000).toFixed(1)}s`);
  state.nkn.reconnectTimer = setTimeout(() => {
    state.nkn.reconnectTimer = null;
    ensureNknClient().catch((err) => logActivity(`Reconnect failed: ${err.message || err}`, false));
  }, delay);
}

function startNknHealthMonitor(){
  stopNknHealthMonitor();
  state.nkn.healthFailures = 0;
  state.nkn.healthInterval = setInterval(() => {
    if (!state.nkn.ready) return;
    ensureRelayReady()
      .then(() => { state.nkn.healthFailures = 0; })
      .catch((err) => {
        state.nkn.healthFailures += 1;
        logActivity(`Relay ping failed (#${state.nkn.healthFailures}): ${err.message || err}`, false);
        if (state.nkn.healthFailures >= 3){
          logActivity('Relay health degraded, resetting NKN client', false);
          if (!usingNovioTransport()){
            resetNknClient();
          }
        }
      });
  }, 20000);
}

function stopNknHealthMonitor(){
  if (state.nkn.healthInterval){
    clearInterval(state.nkn.healthInterval);
    state.nkn.healthInterval = null;
  }
}

function computeAddress(pubkey){
  const clean = (pubkey || '').trim();
  if (!clean) return '';
  if (clean.includes('.') && clean.length > 10){
    return clean;
  }
  return `inference.${clean}`;
}

function syncRelayInputs(){
  state.relayPubkey = (els.pubkeyInput.value || '').trim();
  localStorage.setItem(STORAGE_KEYS.pubkey, state.relayPubkey);
  state.relay = computeAddress(state.relayPubkey);
  els.relayAddress.value = state.relay;
  state.relayVerified = false;
  state.relayInfo = null;
  els.connectBtn.disabled = !state.relay;
  if (els.guestConnectBtn) els.guestConnectBtn.disabled = !state.relay;
  if (!state.relay){
    toast('Pubkey required', false);
    state.nkn.addr = '';
    return;
  }
  if (!state.nkn.ready && !state.nkn.connectPromise){
    toast('Connecting to NKN…', true);
    logActivity('Starting NKN connection...');
    ensureNknClient().catch(err => {
      toast(String(err), false);
      logActivity(`NKN connection failed: ${err}`, false);
    });
  } else if (state.nkn.ready) {
    // NKN already connected, check relay (maybe trigger auto-login)
    checkRelay()
      .then(() => ensureAutoLogin('nkn ready').catch(() => {}))
      .catch((err) => toast(err.message || 'Relay probe failed', false));
  }
}

function requireRelay(){
  if (!state.relay){
    toast('Enter relay pubkey first', false);
    return false;
  }
  return true;
}

async function ensureRelayReady(){
  if (!requireRelay()) throw new Error('Relay address required');
  if (state.relayVerified) return state.relayInfo;
  try {
    return await checkRelay();
  } catch (err){
    state.relayVerified = false;
    state.relayInfo = null;
    logActivity(`Relay probe failed: ${err.message || err}`, false);
    return null;
  }
}

async function checkRelay(){
  if (!requireRelay()) throw new Error('Relay address required');
  const info = await nknSendRequestWithRetry({ event: 'relay.info' });
  state.relayVerified = true;
  state.relayInfo = info;
  const summary = info && info.model ? `Relay ready · model ${info.model}` : 'Relay info received';
  logActivity(summary, true);
  syncCurrentModelFromState(info && info.model);
  updateChatPlaceholder();
  setNknStatus('green', 'Connected', getPeerCount(info));
  if (info && info.model && state.modelStatus.phase === 'idle'){
    setModelStatus('idle', { description: `${info.model} ready`, model: info.model });
  }

  await ensureAutoLogin('relay probe');

  return info;
}

function switchLoginModalState(newState){
  // newState: 'connect' or 'auth'
  els.loginModal.classList.remove('state-connect', 'state-auth');
  els.loginModal.classList.add(`state-${newState}`);

  if (newState === 'auth') {
    els.modalSubtitle.textContent = 'Secure authenticated AI chat over NKN relay';
  } else {
    els.modalSubtitle.textContent = 'Connect to NKN relay to begin';
  }
}

function updateSessionUI(){
  if (state.session){
    els.sessionStatus.textContent = `Hi ${state.session.username}`;
    els.sendBtn.disabled = state.busy;
    switchToView('chat');
  } else {
    els.sessionStatus.textContent = 'Not signed in.';
    els.sendBtn.disabled = true;
    switchToView('login');
  }
  syncCurrentModelFromState();
}

function describeModelPhase(phase, meta = {}){
  const modelName = meta.model || getModelLabel();
  switch (phase){
    case 'loading':
      return `Loading ${modelName}…`;
    case 'streaming':
      return 'Streaming response…';
    case 'error':
      return meta.detail ? `Model error · ${meta.detail}` : 'Model error';
    case 'idle':
    default:
      return `${modelName} ready`;
  }
}

const statusColorClasses = ['status-green', 'status-yellow', 'status-red', 'status-pink'];

function applyIndicatorColor(el, colorClass){
  if (!el) return;
  statusColorClasses.forEach((cls) => el.classList.toggle(cls, cls === colorClass));
}

function phaseToColor(phase){
  switch (phase){
    case 'loading':
      return 'status-yellow';
    case 'error':
      return 'status-red';
    case 'streaming':
    case 'idle':
    default:
      return 'status-green';
  }
}

function setModelStatus(phase, meta = {}){
  const description = meta.description || meta.message || describeModelPhase(phase, meta);
  state.modelStatus = { phase, description, meta };
  if (els.modelStatusPill){
    els.modelStatusPill.textContent = description;
    els.modelStatusPill.dataset.phase = phase;
    applyIndicatorColor(els.modelStatusPill, phaseToColor(phase));
    setModelSpinner(phase === 'loading');
    if (meta.detail || meta.error){
      els.modelStatusPill.title = meta.detail || meta.error;
    } else if (meta.model || (state.relayInfo && state.relayInfo.model)){
      els.modelStatusPill.title = meta.model || state.relayInfo.model || '';
    } else {
      els.modelStatusPill.removeAttribute('title');
    }
  }
  updateModelDisplay(description);
}

function setModelSpinner(visible){
  if (!els.modelSpinner) return;
  els.modelSpinner.classList.toggle('hidden', !visible);
}

function setModelMetrics(latencyMs, tps){
  if (els.modelLatency){
    els.modelLatency.textContent = `Latency · ${latencyMs ? `${Math.round(latencyMs)}ms` : '—'}`;
  }
  if (els.modelTps){
    if (tps !== undefined && tps !== null && !Number.isNaN(Number(tps))){
      els.modelTps.textContent = `TPS · ${Number(tps).toFixed(2)}`;
    } else {
      els.modelTps.textContent = 'TPS · —';
    }
  }
}

function setNknStatus(level, label, peers){
  if (!els.nknStatusChat) return;
  const normalizedLevel = (level || '').toLowerCase();
  const normalizedLabel = (label || '').toLowerCase();
  let colorClass = 'status-pink';
  if (normalizedLevel === 'green' || /connected/i.test(normalizedLabel)) {
    colorClass = 'status-green';
  } else if (normalizedLevel === 'yellow' || /connecting/i.test(normalizedLabel)) {
    colorClass = 'status-yellow';
  } else if (
    normalizedLevel === 'red' ||
    /(disconnect|disconnected|error|fail|hard failure|down)/i.test(normalizedLabel)
  ) {
    colorClass = 'status-red';
  }
  applyIndicatorColor(els.nknStatusChat, colorClass);
  const suffix = peers !== undefined ? ` · Peers: ${peers}` : '';
  els.nknStatusChat.textContent = `${label || els.nknStatusChat.textContent}${suffix}`;
}

function getPeerCount(info){
  const payload = info || state.relayInfo || {};
  if (typeof payload.peer_count === 'number'){
    return payload.peer_count;
  }
  return state.session ? 1 : 0;
}

function applyModelStatusEvent(data){
  if (!data) return;
  const phase = data.phase || 'idle';
  setModelMetrics(data.latency_ms, data.tps);
  setModelStatus(phase, data);
  if (data.model) {
    syncCurrentModelFromState(data.model);
  }
  const detail = data.detail || data.description || '';
  const ok = phase !== 'error';
  const activity = detail ? `${phase} · ${detail}` : phase;
  logActivity(`Model ${activity}`, ok);
}

function updateHardwareStats(stats){
  if (!stats || !els.hardwarePanel) return;
  const hasGpu = stats.gpu_available;
  const utilPercent = Math.min(Math.max(Number(stats.gpu_util_percent || 0), 0), 100);
  if (hasGpu && els.gpuUtilBar){
    els.gpuUtilBar.style.width = `${utilPercent}%`;
    els.gpuUtilLabel.textContent = `${utilPercent.toFixed(0)}%`;
  }
  if (hasGpu && els.gpuMemLabel){
    const used = Number(stats.mem_used_mb || 0);
    const total = Number(stats.mem_total_mb || 0);
    els.gpuMemLabel.textContent = `${used} / ${total} MB`;
  }
  if (els.gpuTempLabel){
    els.gpuTempLabel.textContent = `${stats.temperature_c ? `${stats.temperature_c.toFixed(0)}°C` : '—°C'}`;
  }
  if (els.hardwareStatusLabel){
    if (!hasGpu){
      els.hardwareStatusLabel.textContent = stats.error ? stats.error : 'GPU unavailable';
    } else {
      const ready = stats.model_ready ? 'Model ready' : 'Model loading';
      els.hardwareStatusLabel.textContent = `${ready} · ${stats.power_draw_w ? `${stats.power_draw_w.toFixed(1)}W` : ''}`;
    }
  }
  if (els.sessionHardwareInline){
    els.sessionHardwareInline.dataset.gpuAvailable = hasGpu ? 'true' : 'false';
    if (els.sessionGpuUtilBarInline){
      els.sessionGpuUtilBarInline.style.width = hasGpu ? `${utilPercent}%` : '0%';
    }
    if (els.sessionGpuUtilLabelInline){
      els.sessionGpuUtilLabelInline.textContent = hasGpu ? `${utilPercent.toFixed(0)}%` : '—%';
    }
  }
}

setModelStatus(state.modelStatus.phase, { description: state.modelStatus.description });

async function attemptAutoLogin(){
  if (state.autoLoginTried || state.autoLoginInProgress) return null;
  if (!state.savedCreds || state.session) return null;
  state.autoLoginInProgress = true;
  logActivity('Attempting auto login…');
  let result = null;
  try {
    result = await performLogin(state.savedCreds.username, state.savedCreds.password, { auto: true });
    if (result && result.success){
      state.autoLoginTried = true;
      return result;
    }
    const invalidCreds = isInvalidCredentialsError(result && result.error);
    if (invalidCreds){
      localStorage.removeItem(AUTO_LOGIN_KEY);
      state.savedCreds = null;
      state.autoLoginTried = true;
      prefillSavedCreds();
    } else {
      state.autoLoginTried = false;
    }
    return result;
  } finally {
    state.autoLoginInProgress = false;
  }
}

async function ensureAutoLogin(context = 'auto'){
  if (state.session || !state.savedCreds) return null;
  if (state.autoLoginTried || state.autoLoginInProgress) return null;
  logActivity(`Triggering auto-login with saved credentials (${context})...`);
  return await attemptAutoLogin();
}

function renderBubble(role, content, messageId){
  const wrapper = document.createElement('div');
  wrapper.className = `chat-message chat-message-${role}`;
  if (messageId) {
    wrapper.dataset.messageId = messageId;
  }
  const meta = document.createElement('div');
  meta.className = 'chat-meta';
  const messageObj = messageId ? state.messages.find(m => m.id === messageId) : null;
  const label = role === 'user' ? 'You' : (messageObj && messageObj.model) ? messageObj.model : getModelLabel();
  meta.textContent = label;
  const bubble = document.createElement('div');
  bubble.className = `chat-bubble chat-bubble-${role}`;
  const thumb = messageObj?.image_thumb || (messageId ? getCachedThumb(messageId) : null);
  let body = null;
  if (role === 'assistant'){
    body = document.createElement('div');
    body.className = 'markdown-body';
    bubble.appendChild(body);
  } else {
    if (thumb){
      const img = document.createElement('img');
      img.className = 'chat-thumb';
      img.src = thumb;
      img.alt = 'thumbnail';
      bubble.appendChild(img);
    }
    const textNode = document.createElement('div');
    textNode.textContent = content;
    bubble.appendChild(textNode);
    recordDisplayedMessageContent(messageId, content);
  }
  wrapper.appendChild(meta);
  wrapper.appendChild(bubble);
  els.chat.appendChild(wrapper);
  scrollChatToBottom();
  return body;
}

function addReloadAction(body){
  if (!body) return;
  const existing = body.querySelector('.reauth-action');
  if (existing) return;
  const action = document.createElement('div');
  action.className = 'reauth-action';
  const label = document.createElement('span');
  label.textContent = 'Session expired. Reload to re-authenticate.';
  const button = document.createElement('button');
  button.type = 'button';
  button.textContent = 'Reload';
  button.addEventListener('click', () => {
    window.location.reload();
  });
  action.appendChild(label);
  action.appendChild(button);
  body.appendChild(action);
}

function renderHistory(){
  displayedMessageContents.clear();
  const scrollBtn = els.scrollResumeBtn && els.scrollResumeBtn.parentNode === els.chat ? els.scrollResumeBtn : null;
  if (scrollBtn) {
    scrollBtn.remove();
  }
  els.chat.innerHTML = '';
  state.messages.forEach((msg) => {
    if (!msg || !msg.role) return;
      if (msg.role === 'assistant'){
        const body = renderBubble('assistant', '', msg.id);
        renderMarkdown(body, msg.content || '');
        recordDisplayedMessageContent(msg.id, msg.content || '');
        maybeTriggerTimeoutRefresh(msg.content || '', msg.id);

      // Show indicator and refresh button for incomplete messages
      if (msg.is_complete === false) {
        const incomplete = document.createElement('div');
        incomplete.style.cssText = 'margin-top: 8px; padding: 6px 10px; background: var(--bg-panel); border: 1px solid var(--border-subtle); border-radius: 0.5rem; font-size: 11px; color: var(--text-main); display: flex; align-items: center; gap: 8px;';
        const isAutoRefreshing = autoRefreshTimer !== null;
        incomplete.innerHTML = `
          <span>${isAutoRefreshing ? '🔄' : '⚠️'} ${isAutoRefreshing ? 'Auto-recovering...' : 'Incomplete (connection interrupted)'}</span>
          <button onclick="refreshIncompleteMessage('${msg.id}')" style="padding: 2px 8px; border: 1px solid var(--border-subtle); border-radius: 0.5rem; cursor: pointer; font-size: 10px; font-weight: 600; color: var(--);">Refresh Now</button>
        `;
        body.parentElement.appendChild(incomplete);
      }
    } else {
      renderBubble('user', msg.content || '', msg.id);
    }
  });
  if (scrollBtn) {
    els.chat.appendChild(scrollBtn);
  }
  // Auto-scroll to bottom after rendering history
  // Use requestAnimationFrame to ensure DOM is fully updated, especially markdown rendering
  requestAnimationFrame(() => {
    scrollChatToBottom();
  });
  if (typingAnimationActive && currentTypingMessageId) {
    const activeBubble = els.chat.querySelector(`[data-message-id="${currentTypingMessageId}"] .markdown-body`);
    if (activeBubble) {
      currentTypingNode = activeBubble;
      renderMarkdown(currentTypingNode, currentTypingText || '');
    }
  }
  // Check for incomplete messages and start auto-refresh if needed
  checkIncompleteMessages();
}

async function copyToClipboard(text){
  try {
    if (navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(text || '');
      return true;
    }
  } catch (err) {
    console.warn('Clipboard API failed, falling back', err);
  }
  const textarea = document.createElement('textarea');
  textarea.value = text || '';
  textarea.setAttribute('readonly', '');
  textarea.style.position = 'fixed';
  textarea.style.top = '-9999px';
  textarea.style.opacity = '0';
  document.body.appendChild(textarea);
  textarea.select();
  let ok = false;
  try {
    ok = document.execCommand('copy');
  } catch (err) {
    ok = false;
  }
  document.body.removeChild(textarea);
  return ok;
}

function enhanceCodeBlocks(root){
  if (!root) return;
  const codeBlocks = root.querySelectorAll('pre > code');
  codeBlocks.forEach((code) => {
    const pre = code.parentElement;
    if (!pre || pre.dataset.enhanced === 'true') return;
    pre.dataset.enhanced = 'true';

    if (window.hljs){
      try {
        hljs.highlightElement(code);
      } catch (err) {
        console.warn('Highlight failed', err);
      }
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'code-block-wrapper';
    pre.parentNode.insertBefore(wrapper, pre);
    wrapper.appendChild(pre);

    const copyBtn = document.createElement('button');
    copyBtn.type = 'button';
    copyBtn.className = 'copy-code-btn';
    copyBtn.textContent = 'Copy';
    copyBtn.addEventListener('click', async () => {
      const ok = await copyToClipboard(code.textContent || '');
      copyBtn.textContent = ok ? 'Copied!' : 'Copy failed';
      copyBtn.classList.toggle('copied', ok);
      setTimeout(() => {
        copyBtn.textContent = 'Copy';
        copyBtn.classList.remove('copied');
      }, 1400);
    });

    wrapper.appendChild(copyBtn);
  });
}

function renderMarkdown(node, text){
  if (!node) return;
  if (window.marked){
    node.innerHTML = marked.parse(text || '');
  } else {
    node.textContent = text || '';
  }
  enhanceCodeBlocks(node);
}

function setBusy(v){
  state.busy = v;
  if (state.session){
    els.sendBtn.disabled = v;
  }
}

// Auto-refresh state
let autoRefreshTimer = null;
const displayedMessageContents = new Map();
const timeoutRefreshTriggered = new Set();

function recordDisplayedMessageContent(messageId, text) {
  if (!messageId) return;
  displayedMessageContents.set(messageId, text || '');
}

function maybeTriggerTimeoutRefresh(content, messageId){
  const text = (content || '').toLowerCase();
  if (!text) return;
  const matches = text.includes('failed to send with any client') || text.includes('message timeout');
  if (!matches) return;
  const key = messageId || text;
  if (timeoutRefreshTriggered.has(key)) return;
  timeoutRefreshTriggered.add(key);
  logActivity('Detected timeout in chat bubble, refreshing DB state...');
  window.refreshIncompleteMessage('auto');
}

// Typing animation state
let typingQueue = [];
let typingAnimationActive = false;
let currentTypingNode = null;
let currentTypingText = '';
let currentTypingMessageId = null;
let typingChunkInProgress = false;

function startTypingAnimation(targetNode, messageId = null, initialText = '') {
  if (typingAnimationActive) {
    stopTyping();
  }

  typingAnimationActive = true;
  typingQueue = [];
  currentTypingNode = targetNode;
  currentTypingText = initialText || '';
  currentTypingMessageId = messageId;
  if (currentTypingNode) {
    renderMarkdown(currentTypingNode, currentTypingText);
    recordDisplayedMessageContent(currentTypingMessageId, currentTypingText);
  }

  processTypingQueue();
}

async function processTypingQueue() {
  if (!typingAnimationActive) {
    typingQueue = [];
    typingChunkInProgress = false;
    return;
  }

  if (typingChunkInProgress) {
    return;
  }

  if (typingQueue.length === 0) {
    setTimeout(() => processTypingQueue(), 50);
    return;
  }

  const chunk = typingQueue.shift();
  if (chunk === null) {
    typingAnimationActive = false;
    typingQueue = [];
    currentTypingMessageId = null;
    typingChunkInProgress = false;
    return;
  }

  typingChunkInProgress = true;
  await typeChunk(chunk);
  typingChunkInProgress = false;
  processTypingQueue();
}

async function typeChunk(chunk) {
  if (!chunk) return;
  currentTypingText += chunk;
  renderMarkdown(currentTypingNode, currentTypingText);
  recordDisplayedMessageContent(currentTypingMessageId, currentTypingText);
  scrollChatToBottom();
  await revealChunkAnimation();
}

async function revealChunkAnimation() {
  if (!currentTypingNode) return;
  return new Promise((resolve) => {
    const overlay = document.createElement('span');
    overlay.className = 'typing-reveal';
    let finished = false;
    const cleanup = () => {
      if (finished) return;
      finished = true;
      if (overlay.parentElement) {
        overlay.remove();
      }
      resolve();
    };
    overlay.addEventListener('animationend', cleanup, { once: true });
    currentTypingNode.appendChild(overlay);
    setTimeout(cleanup, 400);
  });
}

function queueTypingChunk(chunk) {
  typingQueue.push(chunk);
  if (typingAnimationActive) {
    processTypingQueue();
  }
}

function setTypingPlaceholder(text, includeInTyping = false) {
  if (!currentTypingNode) return;
  renderMarkdown(currentTypingNode, text);
  scrollChatToBottom();
  if (includeInTyping) {
    currentTypingText = text;
    recordDisplayedMessageContent(currentTypingMessageId, currentTypingText);
  }
}

function clearTypingPlaceholder() {
  if (!currentTypingNode) return;
  currentTypingText = '';
  renderMarkdown(currentTypingNode, '');
  recordDisplayedMessageContent(currentTypingMessageId, '');
}

function syncTypingPlaceholderToModelStatus(statusPayload) {
  if (!currentTypingNode) return;
  const payload = statusPayload || state.modelStatus;
  if (!payload) return;
  const phase = payload.phase || 'idle';
  if (phase === 'streaming' || phase === 'error') return;
  const detail = payload.detail || payload.description || '';
  if (!detail) return;
  setTypingPlaceholder(`_${detail}_`);
}

function endTyping() {
  typingQueue.push(null); // Signal end
  processTypingQueue();
}

function stopTyping() {
  typingAnimationActive = false;
  typingQueue = [];
  currentTypingMessageId = null;
  typingChunkInProgress = false;
  currentTypingNode = null;
  currentTypingText = '';
}

// Global function for incomplete message refresh
window.refreshIncompleteMessage = async function(messageId) {
  try {
    const prevDisplayed = new Map(displayedMessageContents);
    const refreshData = await nknSendRequestWithRetry({ event: 'chat.refresh' }, { maxAttempts: 2, timeoutMs: 5000 });
    if (refreshData && refreshData.messages) {
      state.messages = mergeMessages(state.messages, refreshData.messages);
      renderHistory();
      if (messageId === 'auto') {
        animateAutoRecoverTyping(prevDisplayed);
      }
      if (messageId !== 'auto') {
        toast('Message refreshed');
      }
      logActivity(`Refreshed incomplete message ${messageId}`);
    }
  } catch (err) {
    if (messageId !== 'auto') {
      toast('Refresh failed: ' + (err.message || err), false);
    }
    console.warn('Auto-refresh failed:', err);
  }
};

// Check for incomplete messages and start/stop auto-refresh
function checkIncompleteMessages() {
  const hasIncomplete = state.messages.some(msg => msg.is_complete === false);

  if (hasIncomplete && !autoRefreshTimer) {
    // Start auto-refresh timer
    logActivity('Auto-refresh started for incomplete messages');
    autoRefreshTimer = setInterval(async () => {
      const stillIncomplete = state.messages.some(msg => msg.is_complete === false);
      if (stillIncomplete) {
        await window.refreshIncompleteMessage('auto');
      } else {
        // All complete, stop timer
        clearInterval(autoRefreshTimer);
        autoRefreshTimer = null;
        logActivity('Auto-refresh stopped - all messages complete');
      }
    }, 1000); // Every 1 second
  } else if (!hasIncomplete && autoRefreshTimer) {
    // Stop auto-refresh timer
    clearInterval(autoRefreshTimer);
    autoRefreshTimer = null;
    logActivity('Auto-refresh stopped - all messages complete');
  }
}

function animateAutoRecoverTyping(previousContents) {
  if (!previousContents) return;
  if (autoRefreshTimer === null) return;
  const target = [...state.messages].reverse().find(
    (msg) => msg.role === 'assistant' && msg.is_complete === false
  );
  if (!target || !target.id) return;
  const prevText = previousContents.get(target.id) || '';
  const newText = target.content || '';
  if (newText.length <= prevText.length) return;
  const bubble = els.chat.querySelector(`[data-message-id="${target.id}"] .markdown-body`);
  if (!bubble) return;

  stopTyping();
  startTypingAnimation(bubble, target.id, prevText);
  const diff = newText.substring(prevText.length);
  if (diff) {
    queueTypingChunk(diff);
  }
}

async function handleRegister(event){
  event.preventDefault();
  if (!requireRelay()) return;
  const username = (els.registerUser.value || '').trim();
  const password = els.registerPass.value || '';
  if (!username || !password){
    toast('Username/password required', false);
    return;
  }
  if (password.length < 6){
    toast('Password must be at least 6 characters', false);
    return;
  }
  await ensureRelayReady();
  try {
    const resp = await nknSendRequestWithRetry({ event: 'auth.register', username, password });
    const created = resp && resp.username ? resp.username : username;
    toast(`Account created for ${created}. Logging in...`);
    logActivity(`Register OK (${created})`);
    event.target.reset();

    // Automatically log in after successful registration
    await performLogin(username, password, { auto: false });
  } catch (err){
    toast(err.message || 'Register failed', false);
    logActivity(`Register failed: ${err.message || err}`, false);
  }
}

async function handleLogin(event){
  event.preventDefault();
  if (!requireRelay()) return;
  const username = (els.loginUser.value || '').trim();
  const password = els.loginPass.value || '';
  if (!username || !password){
    toast('Username/password required', false);
    return;
  }
  await performLogin(username, password, { auto: false });
}

async function performLogin(username, password, { auto }) {
  await ensureRelayReady();
  try {
    const resp = await nknSendRequestWithRetry({ event: 'auth.login', username, password });
    const uname = resp.username || username;
    const messages = Array.isArray(resp.messages) ? resp.messages : [];
    const sessions = Array.isArray(resp.sessions) ? resp.sessions : [];
    const currentSessionId = resp.current_session_id || null;
    state.userPreferences = (resp.preferences && typeof resp.preferences === 'object') ? resp.preferences : {};
    if (state.userPreferences.theme) {
      applyTheme(state.userPreferences.theme);
    }
    state.tools = Array.isArray(state.userPreferences.tools) ? state.userPreferences.tools : [];
    updateToolsChip();

    applyLoginSuccess(uname, sessions, currentSessionId, messages, resp.current_session_model);

    // Save credentials for auto-login on next session
    saveCredentials(username, password);

    toast(`${auto ? 'Auto-signed' : 'Signed'} in as ${uname}`);
    logActivity(`${auto ? 'Auto login' : 'Login'} OK (${uname})`);
    if (!auto) {
      els.input.focus();
      // Clear password fields after manual login
      els.loginPass.value = '';
      els.registerPass.value = '';
    }
    return { success: true };
  } catch (err){
    toast(err.message || 'Login failed', false);
    logActivity(`${auto ? 'Auto login' : 'Login'} failed: ${err.message || err}`, false);
    return { success: false, error: err };
  }
}

function applyLoginSuccess(username, sessions, currentSessionId, messages, currentSessionModel){
  state.session = { username };
  state.sessions = sessions || [];
  state.currentSessionId = currentSessionId;
  if (state.userPreferences && state.userPreferences.theme){
    applyTheme(state.userPreferences.theme);
  }
  if (Array.isArray(state.userPreferences?.tools)) {
    state.tools = state.userPreferences.tools;
    updateToolsChip();
  }
  // Refresh preferences from server to ensure latest (non-blocking)
  fetchUserPreferences().catch(() => {});
  // Add IDs to messages from DB
  state.messages = (messages || []).map(msg => normalizeMessage(msg, currentSessionModel || getModelLabel()));
  syncCurrentModelFromState(currentSessionModel);
  renderSessions();
  renderHistory();
  updateSessionUI();
  updateClientCount();
}

function updateClientCount(){
  const peers = getPeerCount(state.relayInfo);
  if (peers !== undefined){
    const isAuthed = !!state.session;
    const label = isAuthed ? `Signed in as ${state.session?.username}` : 'Connected';
    setNknStatus(isAuthed ? 'pink' : 'green', label, peers);
  }
}

async function handleLogout(){
  if (!state.session) return;
  try {
    await nknSendRequestWithRetry({ event: 'auth.logout' });
  } catch (err){
    toast(err.message || 'Logout failed', false);
  }
  state.session = null;
  state.sessions = [];
  state.currentSessionId = null;
  state.messages = [];
  state.userPreferences = {};
  state.tools = [];
  state.selectedModel = null;
  state.availableModels = [];
  // Clear auto-refresh timer
  if (autoRefreshTimer) {
    clearInterval(autoRefreshTimer);
    autoRefreshTimer = null;
  }
  // Stop any active typing animation
  stopTyping();
  renderHistory();
  updateSessionUI();
  // Clear saved credentials
  localStorage.removeItem(AUTO_LOGIN_KEY);
  state.savedCreds = null;
  prefillSavedCreds();
  // Reset modal to connect state
  switchLoginModalState('connect');
  updateToolsChip();
}

function generateMessageId(){
  return `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

function normalizeMessage(msg, fallbackModel){
  const normalized = { ...msg };
  if (!normalized.id) normalized.id = normalized.uuid || generateMessageId();
  normalized.model = normalized.model || fallbackModel || getModelLabel();
  if (normalized.image_thumb) {
    cacheThumb(normalized.id, normalized.image_thumb);
  }
  if (!normalized.image_thumb) {
    normalized.image_thumb = getCachedThumb(normalized.id);
  }
  return normalized;
}

function formatCapabilityBadges(capabilities){
  const caps = capabilities || {};
  const labels = Object.entries(caps)
    .filter(([, enabled]) => !!enabled)
    .map(([key]) => {
      switch (key) {
        case 'supports_images': return 'Images';
        case 'supports_thinking': return 'Thinking';
        case 'supports_tools': return 'Tools';
        default: return key.replace(/_/g, ' ');
      }
    });
  return labels.map(label => `<span class="chip">${label}</span>`).join(' ');
}

function addUploadStatus(uploadId, totalChunks, fileLabel, thumbnailUrl){
  if (!els.chat) return;
  const wrapper = document.createElement('div');
  wrapper.className = 'chat-message chat-message-assistant';
  wrapper.dataset.uploadId = uploadId;
  const meta = document.createElement('div');
  meta.className = 'chat-meta';
  meta.textContent = 'Sending image…';
  const bubble = document.createElement('div');
  bubble.className = 'upload-status';
  const thumbHtml = thumbnailUrl ? `<img src="${thumbnailUrl}" class="upload-thumb" alt="preview">` : '';
  bubble.innerHTML = `<span class="status-icon">⏳</span>${thumbHtml}<div class="upload-meta"><span class="progress" id="upload-progress-${uploadId}">0/${totalChunks}</span><span class="upload-name">${fileLabel || 'image'}</span></div>`;
  wrapper.appendChild(meta);
  wrapper.appendChild(bubble);
  els.chat.appendChild(wrapper);
  scrollChatToBottom();
  state.uploadStatuses.set(uploadId, { wrapper, bubble, progress: bubble.querySelector(`#upload-progress-${uploadId}`), total: totalChunks, statusIcon: bubble.querySelector('.status-icon'), retryBtn: null, messageEl: null });
}

function resetUploadEntry(entry){
  if (!entry) return;
  if (entry.messageEl && entry.messageEl.parentNode){
    entry.messageEl.parentNode.removeChild(entry.messageEl);
  }
  if (entry.retryBtn && entry.retryBtn.parentNode){
    entry.retryBtn.parentNode.removeChild(entry.retryBtn);
  }
  entry.retryBtn = null;
  entry.messageEl = null;
}

function updateUploadStatus(uploadId, received, total){
  const entry = state.uploadStatuses.get(uploadId);
  if (!entry) return;
  resetUploadEntry(entry);
  if (entry.progress) {
    entry.progress.textContent = `${received}/${total || entry.total || '?'}`;
  }
  if (entry.bubble) {
    entry.bubble.classList.remove('success', 'error');
  }
}

function completeUploadStatus(uploadId){
  const entry = state.uploadStatuses.get(uploadId);
  if (!entry) return;
  resetUploadEntry(entry);
  if (entry.progress) entry.progress.textContent = '✓';
  if (entry.bubble) {
    entry.bubble.classList.remove('error');
    entry.bubble.classList.add('success');
    const icon = entry.statusIcon || entry.bubble.querySelector('.status-icon');
    if (icon) icon.textContent = '✓';
  }
}

function failUploadStatus(uploadId, message, options = {}){
  const entry = state.uploadStatuses.get(uploadId);
  if (!entry) return;
  const { onRetry } = options;
  resetUploadEntry(entry);
  if (entry.progress) entry.progress.textContent = '✕';
  if (entry.bubble) {
    entry.bubble.classList.remove('success');
    entry.bubble.classList.add('error');
    const icon = entry.statusIcon || entry.bubble.querySelector('.status-icon');
    if (icon) icon.textContent = '✕';
    const msg = document.createElement('span');
    msg.textContent = message || 'Upload failed';
    entry.messageEl = msg;
    entry.bubble.appendChild(msg);
    if (typeof onRetry === 'function') {
      const retryBtn = document.createElement('button');
      retryBtn.type = 'button';
      retryBtn.className = 'upload-retry-btn';
      retryBtn.textContent = 'Retry';
      retryBtn.addEventListener('click', () => onRetry());
      entry.retryBtn = retryBtn;
      entry.bubble.appendChild(retryBtn);
    }
  }
}

function removeUploadStatus(uploadId){
  const entry = state.uploadStatuses.get(uploadId);
  if (!entry) return;
  resetUploadEntry(entry);
  if (entry.wrapper && entry.wrapper.parentNode) {
    entry.wrapper.parentNode.removeChild(entry.wrapper);
  }
  state.uploadStatuses.delete(uploadId);
}

function clearUploadTracking(uploadId, { removeStatus = true, delayMs = 0 } = {}){
  const guard = state.uploadGuards.get(uploadId);
  if (guard) clearTimeout(guard);
  state.uploadGuards.delete(uploadId);
  state.uploadToAssistant.delete(uploadId);
  state.uploadJobs.delete(uploadId);
  if (removeStatus){
    if (delayMs > 0) {
      setTimeout(() => removeUploadStatus(uploadId), delayMs);
    } else {
      removeUploadStatus(uploadId);
    }
  }
}

function registerUploadGuard(uploadId, assistantId, timeoutMs = 60000){
  if (!uploadId) return;
  state.uploadToAssistant.set(uploadId, assistantId);
  const existing = state.uploadGuards.get(uploadId);
  if (existing) clearTimeout(existing);
  const timer = setTimeout(() => {
    const job = state.uploadJobs.get(uploadId);
    if (job && job.completed) {
      clearUploadTracking(uploadId, { removeStatus: true });
      cancelUploadGuard(uploadId);
      return;
    }
    if (state.uploadStatuses.has(uploadId)) {
      failUploadStatus(uploadId, 'Timed out waiting for reply', { onRetry: () => { cancelUploadGuard(uploadId); retryUpload(uploadId); } });
      renderUploadFailureMessage('Upload timed out before model responded.', uploadId);
      cancelUploadGuard(uploadId);
      const cleanupTimer = setTimeout(() => clearUploadTracking(uploadId, { removeStatus: true }), 8000);
      state.uploadGuards.set(uploadId, cleanupTimer);
    } else {
      clearUploadTracking(uploadId, { removeStatus: false });
    }
  }, timeoutMs);
  state.uploadGuards.set(uploadId, timer);
}

function cancelUploadGuard(uploadId){
  const guard = state.uploadGuards.get(uploadId);
  if (guard) clearTimeout(guard);
  state.uploadGuards.delete(uploadId);
}

function renderUploadFailureMessage(reason, uploadId){
  const job = uploadId ? state.uploadJobs.get(uploadId) : null;
  if (job && (job.failureNoted || job.completed)) return;
  if (job) job.failureNoted = true;
  const friendly = reason ? `Image upload failed: ${reason}` : 'Image upload failed.';
  const msgId = generateMessageId();
  const content = `*${friendly}* Please retry your message.`;
  renderBubble('assistant', content, msgId);
  state.messages.push({ id: msgId, role: 'assistant', content, is_complete: true, model: getModelLabel() });
}

function markUploadCompleted(uploadId){
  const job = state.uploadJobs.get(uploadId);
  if (job) job.completed = true;
}

async function sendImageChunkWithAck(uploadId, chunk, job){
  if (!requireRelay()) throw new Error('Relay address required');
  await ensureNknClient();
  const label = `${chunk.i + 1}/${chunk.t}`;
  const sendOnce = async () => {
    logActivity(`DM → image.upload ${label} (${uploadId}) len=${(chunk.data || '').length}`);
    const resp = await nknSendRequestWithRetry({
      event: 'image.upload',
      upload_id: uploadId,
      i: chunk.i,
      t: chunk.t,
      data: chunk.data,
      mime: job.mime,
      name: job.name
    }, { timeoutMs: 15000, maxAttempts: 3 });
    logActivity(`DM ← image.upload.ack ${label} (${uploadId}) received=${resp.received} total=${resp.total}`);
    return resp;
  };
  try {
    const resp = await sendOnce();
    if (resp.upload_id && resp.upload_id !== uploadId){
      throw new Error('Upload ID mismatch in ack');
    }
    if (typeof resp.received === 'number' && resp.received < chunk.i + 1){
      throw new Error('Upload ack missing chunk confirmation');
    }
    return resp;
  } catch (err){
    const msg = String(err && err.message || err || '');
    if (/RTCDataChannel\.readyState is not 'open'/i.test(msg)){
      logActivity(`RTC channel not open, retrying chunk ${label} after reconnect`, false);
      resetNknClient();
      await ensureNknClient();
      const resp = await sendOnce();
      if (resp.upload_id && resp.upload_id !== uploadId){
        throw new Error('Upload ID mismatch in ack');
      }
      return resp;
    }
    throw err;
  }
}

async function uploadMissingChunks(uploadId){
  const job = state.uploadJobs.get(uploadId);
  if (!job) throw new Error('Upload not found');
  if (job.inFlight) return;
  if (!state.nkn.ready) logActivity(`[upload ${uploadId}] NKN not ready; will retry`);
  if (!requireRelay()) throw new Error('Relay address required');
  await ensureRelayReady();
  await ensureNknClient();
  job.inFlight = true;
  try {
    const missing = job.chunks.filter((chunk, idx) => !job.acknowledged[idx]);
    const total = job.chunks.length;
    logActivity(`[upload ${uploadId}] sending ${missing.length}/${total} chunks`);
    for (const chunk of missing){
      const resp = await sendImageChunkWithAck(uploadId, chunk, job);
      job.acknowledged[chunk.i] = true;
      const received = job.acknowledged.filter(Boolean).length;
      updateUploadStatus(uploadId, resp.received || received, resp.total || total);
      if (resp.complete || received === total) {
        completeUploadStatus(uploadId);
      }
    }
    const receivedTotal = job.acknowledged.filter(Boolean).length;
    if (receivedTotal === total && !state.uploadToAssistant.has(uploadId)) {
      clearUploadTracking(uploadId, { removeStatus: true, delayMs: 400 });
    }
  } finally {
    job.inFlight = false;
    const receivedTotal = job.acknowledged.filter(Boolean).length;
    if (receivedTotal === job.chunks.length) {
      markUploadCompleted(uploadId);
    }
  }
}

async function retryUpload(uploadId){
  const job = state.uploadJobs.get(uploadId);
  if (!job || job.inFlight) return;
  try {
    await uploadMissingChunks(uploadId);
    toast('Upload resumed', true);
  } catch (err){
    failUploadStatus(uploadId, err.message || 'Upload failed', { onRetry: () => retryUpload(uploadId) });
    renderUploadFailureMessage(err.message || 'Could not upload image.', uploadId);
  }
}

function mergeMessages(localMessages, dbMessages){
  // Merge DB messages with local messages, avoiding duplicates using UUIDs
  const messageMap = new Map();
  const fallbackModel = getModelLabel();

  // First, add all local messages (they have UUIDs)
  localMessages.forEach(msg => {
    if (msg.id) {
      messageMap.set(msg.id, normalizeMessage(msg, fallbackModel));
    }
  });

  // Then add DB messages, using UUID as key (backend now returns UUIDs as 'id')
  dbMessages.forEach(msg => {
    let candidate = normalizeMessage(msg, fallbackModel);
    // If message has UUID and it's already in the map, update with DB version (it might be more complete)
    if (candidate.id && messageMap.has(candidate.id)) {
      const existing = messageMap.get(candidate.id);
      // Update if DB version is more complete or has more content
      if (candidate.is_complete || (candidate.content && candidate.content.length > (existing.content || '').length)) {
        messageMap.set(candidate.id, { ...existing, ...candidate });
      } else if (candidate.image_thumb && !existing.image_thumb){
        messageMap.set(candidate.id, { ...existing, image_thumb: candidate.image_thumb });
      }
      return;
    }

    // If no UUID, try content-based matching as fallback
    if (!candidate.id) {
      let found = false;
      for (const localMsg of messageMap.values()) {
        if (localMsg.role === candidate.role && localMsg.content === candidate.content) {
          found = true;
          break;
        }
      }
      if (found) return;

      // Add with generated ID
      candidate = { ...candidate, id: generateMessageId() };
    }

    messageMap.set(candidate.id, candidate);
  });

  // Convert back to array
  return Array.from(messageMap.values());
}

function updateToolVisibility(){
  const modelName = getModelLabel();
  const caps = state.currentCapabilities || {};
  const entry = (state.availableModels || []).find((m) => m.name === modelName);
  const supportsImages = caps.supports_images || (entry && entry.capabilities && entry.capabilities.supports_images) || (state.modelCapsCache.get(modelName || '') || {}).supports_images;
  const showImages = !!supportsImages;
  if (els.imageTool){
    els.imageTool.classList.toggle('hidden', !showImages);
    if (showImages) els.imageTool.classList.remove('hidden');
    if (els.attachImageBtn){
      els.attachImageBtn.disabled = !showImages;
      els.attachImageBtn.classList.toggle('hidden', !showImages);
      if (showImages) els.attachImageBtn.classList.remove('hidden');
    }
    if (els.imageInput) els.imageInput.disabled = !showImages;
    if (!showImages) removePendingImage();
  }
  const supportsTools = caps.supports_tools || (entry && entry.capabilities && entry.capabilities.supports_tools) || (state.modelCapsCache.get(modelName || '') || {}).supports_tools;
  const showTools = !!supportsTools;
  if (els.toolsTool){
    els.toolsTool.classList.toggle('hidden', !showTools);
    if (els.manageToolsBtn) els.manageToolsBtn.disabled = !showTools;
    updateToolsChip();
  }
  if (els.thinkingChip){
    els.thinkingChip.classList.toggle('hidden', !caps.supports_thinking);
    if (!caps.supports_thinking){
      state.thinkingEnabled = false;
      if (els.thinkingToggle) els.thinkingToggle.checked = false;
      els.thinkingChip.classList.remove('on');
    } else if (els.thinkingToggle && els.thinkingToggle.checked){
      els.thinkingChip.classList.add('on');
    }
  }
}

function forceImageCapabilityFromSelectedModel(){
  const modelName = getModelLabel();
  const entry = (state.availableModels || []).find((m) => m.name === modelName);
  if (entry && entry.capabilities && entry.capabilities.supports_images){
    state.currentCapabilities = { ...state.currentCapabilities, supports_images: true };
  }
}

async function handleImageSelected(event){
  const file = (event.target && event.target.files && event.target.files[0]) || null;
  if (!file){
    state.pendingImage = null;
    updatePendingImageUI();
    return;
  }
  if (file.size > IMAGE_TOTAL_MAX_BYTES){
    toast('Image too large (limit 8MB)', false);
    if (els.imageInput) els.imageInput.value = '';
    removePendingImage();
    return;
  }
  if (file.size >= IMAGE_WARN_THRESHOLD_BYTES){
    const mb = (file.size / (1024 * 1024)).toFixed(2);
    toast(`Warning: large image (${mb} MB). Limit is 8 MB.`, true);
  }
  const reader = new FileReader();
  reader.onload = async () => {
    const dataUrl = reader.result;
    if (!dataUrl || typeof dataUrl !== 'string'){
      toast('Could not read image', false);
      return;
    }
    const base64 = dataUrl.split(',')[1] || '';
    const chunkCount = chunkBase64(base64).length;
    let thumb = '';
    try {
      thumb = await createThumbnail(dataUrl);
    } catch (err){
      console.warn('thumb gen failed', err);
    }
    state.pendingImage = {
      name: file.name || 'image',
      type: file.type || 'application/octet-stream',
      base64,
      chunkCount,
      size: file.size,
      previewUrl: dataUrl,
      thumb,
    };
    updatePendingImageUI();
  };
  reader.onerror = () => toast('Failed to read image', false);
  reader.readAsDataURL(file);
}

function removePendingImage(){
  state.pendingImage = null;
  if (els.imageInput) els.imageInput.value = '';
  updatePendingImageUI();
}

function updatePendingImageUI(){
  if (!els.imageChip) return;
  if (state.pendingImage){
    els.imageChip.classList.remove('hidden');
    if (els.imageChipLabel) {
      const sizeKb = state.pendingImage.size ? Math.round(state.pendingImage.size / 1024) : '';
      const labelParts = [
        state.pendingImage.name || 'image',
        sizeKb ? `${sizeKb} KB` : '',
        state.pendingImage.chunkCount ? `${state.pendingImage.chunkCount} chunks` : ''
      ].filter(Boolean);
      els.imageChipLabel.textContent = labelParts.join(' · ');
    }
  } else {
    els.imageChip.classList.add('hidden');
  }
}

function validToolDefinition(tool){
  if (!tool || typeof tool !== 'object') return false;
  const fn = tool.function || {};
  return tool.type === 'function' && !!fn.name && typeof fn.parameters === 'object';
}

function getActiveTools(){
  if (!Array.isArray(state.tools)) return [];
  return state.tools.filter(validToolDefinition);
}

function updateToolsChip(){
  if (!els.toolsChip) return;
  const count = getActiveTools().length;
  els.toolsChip.classList.toggle('hidden', !count);
  if (els.toolsChipLabel){
    els.toolsChipLabel.textContent = count ? `${count} tool${count === 1 ? '' : 's'}` : '';
  }
}

function handleToolCallsEvent(toolCalls){
  const calls = Array.isArray(toolCalls) ? toolCalls : (toolCalls ? [toolCalls] : []);
  if (!calls.length) return;
  const summaries = calls.map((call) => {
    const fn = (call && call.function) || {};
    let args = fn.arguments;
    if (args && typeof args === 'object'){
      try { args = JSON.stringify(args); } catch (_) { args = '[object]'; }
    }
    return `• ${fn.name || 'tool'}(${args || ''})`;
  });
  logActivity(`Tool call: ${summaries.join(' | ')}`);
  const body = renderBubble('assistant', '', generateMessageId());
  const content = `*Model requested tool call(s):*\n${summaries.join('\n')}\n\n_Tool execution is not automated; run the requested tool manually._`;
  renderMarkdown(body, content);
  maybeTriggerTimeoutRefresh(content, null);
}

const IMAGE_CHUNK_MAX_BYTES = 60 * 1024; // keep under RTC send limits
const IMAGE_TOTAL_MAX_BYTES = 8 * 1024 * 1024;
const IMAGE_WARN_THRESHOLD_BYTES = 7.5 * 1024 * 1024;

function createThumbnail(dataUrl, maxSize = 256, quality = 0.75){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      let { width, height } = img;
      if (width > height){
        if (width > maxSize){
          height = Math.round((height * maxSize) / width);
          width = maxSize;
        }
      } else {
        if (height > maxSize){
          width = Math.round((width * maxSize) / height);
          height = maxSize;
        }
      }
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        reject(new Error('canvas unavailable'));
        return;
      }
      ctx.drawImage(img, 0, 0, width, height);
      const thumb = canvas.toDataURL('image/jpeg', quality);
      resolve(thumb);
    };
    img.onerror = () => reject(new Error('thumbnail failed'));
    img.src = dataUrl;
  });
}

function logUploadChecklist(uploadId, job){
  const steps = [];
  if (!state.currentCapabilities.supports_images) steps.push('model lacks image support');
  if (!job) steps.push('no upload job');
  if (!state.pendingImage && !job?.previewUrl) steps.push('no pending image selected');
  if (!requireRelay(false)) steps.push('relay not configured');
  if (!state.nkn.ready) steps.push('NKN not connected');
  if (job && job.chunks?.length){
    steps.push(`chunks=${job.chunks.length}`);
    const base64Len = state.pendingImage?.base64?.length || 0;
    steps.push(`b64_len=${base64Len}`);
  }
  const label = uploadId ? `upload ${uploadId}` : 'upload';
  logActivity(`[${label}] checklist: ${steps.join(' · ') || 'ready'}`);
  if (steps.length) {
    toast(`Upload checklist: ${steps.join(', ')}`, false);
  }
}

function chunkBase64(str, maxChunkBytes = IMAGE_CHUNK_MAX_BYTES){
  const chunks = [];
  let idx = 0;
  let i = 0;
  const total = Math.ceil(str.length / maxChunkBytes);
  while (idx < str.length){
    chunks.push({ i, t: total, data: str.substring(idx, idx + maxChunkBytes) });
    idx += maxChunkBytes;
    i += 1;
  }
  return chunks;
}

async function handleSend(event){
  event.preventDefault();
  if (state.pendingSend) return;
  state.pendingSend = true;
  try {
    if (!state.session){
      toast('Sign in first', false);
      return;
    }
    if (!requireRelay()) return;
    await ensureRelayReady();
    if (state.busy) return;
    const text = (els.input.value || '').trim();
    if (!text) return;
    const caps = state.currentCapabilities || {};
    let imageUploadId = null;
    let pendingImageInfo = state.pendingImage ? { ...state.pendingImage } : null;
    let uploadJob = null;
    let imageThumb = state.pendingImage?.thumb || '';
    if (caps.supports_images && state.pendingImage){
      const uploadId = generateMessageId();
      const chunks = chunkBase64(state.pendingImage.base64);
      uploadJob = {
        id: uploadId,
        chunks,
        acknowledged: new Array(chunks.length).fill(false),
        mime: state.pendingImage.type || 'application/octet-stream',
        name: state.pendingImage.name || 'image',
        previewUrl: state.pendingImage.previewUrl || '',
        size: state.pendingImage.size || 0,
        inFlight: false,
        failureNoted: false,
        completed: false,
      };
      state.uploadJobs.set(uploadId, uploadJob);
      addUploadStatus(uploadId, chunks.length, state.pendingImage.name, uploadJob.previewUrl);
      logUploadChecklist(uploadId, uploadJob);
      try {
        logActivity(`[upload ${uploadId}] initiating image upload (${chunks.length} chunks)`);
        await uploadMissingChunks(uploadId);
        imageUploadId = uploadId;
        removePendingImage();
      } catch (err){
        uploadJob.failureNoted = true;
        failUploadStatus(uploadId, err.message || 'Upload failed', { onRetry: () => retryUpload(uploadId) });
        renderUploadFailureMessage(err.message || 'Image upload failed.', uploadId);
        cancelUploadGuard(uploadId);
        const cleanupTimer = setTimeout(() => clearUploadTracking(uploadId, { removeStatus: true }), 12000);
        state.uploadGuards.set(uploadId, cleanupTimer);
        setBusy(false);
        return;
      }
    }
    els.input.value = '';

    // Add user message with unique ID to prevent duplicates
    const userMsgId = generateMessageId();
    const userModel = getModelLabel();
    if (!imageThumb && pendingImageInfo?.previewUrl){
      try {
        imageThumb = await createThumbnail(pendingImageInfo.previewUrl);
      } catch (_) {}
    }
    state.messages.push({ id: userMsgId, role: 'user', content: text, model: userModel, image_thumb: imageThumb });
    if (imageThumb) cacheThumb(userMsgId, imageThumb);
    renderBubble('user', text, userMsgId);

    let accumulated = '';
    let expectedSeq = 0;
    const deltaBuffer = new Map();  // seq -> delta (for out-of-order deltas)
    const assistantMsgId = generateMessageId();
    const assistantBody = renderBubble('assistant', '', assistantMsgId);
    const assistantMessage = {
      id: assistantMsgId,
      role: 'assistant',
      content: '',
      streaming: true,
      is_complete: false,
      model: userModel,
    };
    state.messages.push(assistantMessage);
    setBusy(true);
    if (imageUploadId) {
      registerUploadGuard(imageUploadId, assistantMsgId);
    }

    // Start typing animation for this assistant message
    startTypingAnimation(assistantBody, assistantMsgId);
    const modelLabel = getModelLabel();
    setModelStatus('loading', { model: modelLabel, description: `Loading ${modelLabel}…` });
    let streamingNoted = false;
    const cancelUploadTimeout = () => {
      if (imageUploadId) {
        cancelUploadGuard(imageUploadId);
      }
    };
    const cleanupUpload = (opts = {}) => {
      if (imageUploadId) {
        markUploadCompleted(imageUploadId);
        clearUploadTracking(imageUploadId, opts);
      }
    };

    const handlers = {
      onDelta(delta, seq, batchSize){
        if (!streamingNoted){
          streamingNoted = true;
          cancelUploadTimeout();
          if (imageUploadId) markUploadCompleted(imageUploadId);
          if (state.modelStatus.phase !== 'streaming'){
            setModelStatus('streaming', { model: modelLabel });
          }
          if (currentTypingNode){
            clearTypingPlaceholder();
            assistantMessage.content = '';
          }
        }
        // Handle sequenced deltas (may be batched)
        let chunkToQueue = '';

        if (seq !== undefined) {
          const deltasToAdd = batchSize || 1;
          if (seq === expectedSeq) {
            // In-order delta
            accumulated += delta || '';
            chunkToQueue = delta || '';
            expectedSeq += deltasToAdd;

            // Process any buffered deltas that are now in order
            while (deltaBuffer.has(expectedSeq)) {
              const bufferedDelta = deltaBuffer.get(expectedSeq);
              accumulated += bufferedDelta;
              chunkToQueue += bufferedDelta;
              deltaBuffer.delete(expectedSeq);
              expectedSeq++;
            }
          } else if (seq > expectedSeq) {
            // Out-of-order delta - buffer it
            deltaBuffer.set(seq, delta);
            logActivity(`Buffered out-of-order delta ${seq} (expected ${expectedSeq})`);
            return; // Don't queue out-of-order deltas yet
          } else {
            // Duplicate delta - ignore
            return;
          }
        } else {
          // Legacy: no sequence number
          accumulated += delta || '';
          chunkToQueue = delta || '';
        }

        // Queue the chunk for typing animation instead of rendering immediately
        if (chunkToQueue) {
          queueTypingChunk(chunkToQueue);
        }
        assistantMessage.content = accumulated || currentTypingText || assistantMessage.content || '';
        assistantMessage.streaming = true;
        assistantMessage.is_complete = false;
      },
      onDone(totalSeq, finalContent){
        cancelUploadTimeout();
        if (imageUploadId) markUploadCompleted(imageUploadId);
        // Apply any buffered out-of-order deltas before finalizing
        if (deltaBuffer.size > 0) {
          const pendingSeqs = Array.from(deltaBuffer.keys()).sort((a, b) => a - b);
          let bufferedText = '';
          pendingSeqs.forEach((seqKey) => {
            const deltaText = deltaBuffer.get(seqKey) || '';
            if (seqKey > expectedSeq) {
              logActivity(`Late delta ${seqKey} arrived after completion (expected ${expectedSeq})`, false);
              expectedSeq = seqKey; // jump to this seq to avoid stalling
            }
            bufferedText += deltaText;
            expectedSeq += 1;
          });
          if (bufferedText) {
            accumulated += bufferedText;
            const trailing = bufferedText.substring(currentTypingText.length);
            const newChunk = trailing || bufferedText;
            if (newChunk) queueTypingChunk(newChunk);
          }
          deltaBuffer.clear();
        }

        // Use final content if provided (most reliable)
        if (finalContent && finalContent.length > accumulated.length) {
          accumulated = finalContent;
          // Queue the remaining content that wasn't streamed
          const remaining = finalContent.substring(currentTypingText.length);
          if (remaining) {
            queueTypingChunk(remaining);
          }
          logActivity(`Final sync: updated to ${finalContent.length} chars`);
        }

        // Signal end of typing animation
        endTyping();

        // Check for missing deltas
        if (totalSeq !== undefined && expectedSeq < totalSeq) {
          logActivity(`Warning: Missing deltas. Expected ${totalSeq}, received ${expectedSeq}`, false);
        }

        if (accumulated){
          assistantMessage.content = accumulated;
        }
        assistantMessage.streaming = false;
        assistantMessage.is_complete = true;
        setBusy(false);
        if (state.modelStatus.phase !== 'idle'){
          setModelStatus('idle', { model: modelLabel });
        }
        cleanupUpload({ removeStatus: true, delayMs: 400 });

        // Do final DB refresh to ensure we're in sync (merge, don't replace)
        nknSendRequestWithRetry({ event: 'chat.refresh' }, { maxAttempts: 1, timeoutMs: 5000 })
          .then(refreshData => {
            if (refreshData) {
              if (refreshData.messages) {
                state.messages = mergeMessages(state.messages, refreshData.messages);
              }
              if (refreshData.sessions) {
                state.sessions = refreshData.sessions;
                renderSessions();
              }
              if (refreshData.current_session_id) state.currentSessionId = refreshData.current_session_id;
              syncCurrentModelFromState(refreshData.current_session_model);
              renderHistory();
              logActivity(`Final DB refresh: ${state.messages.length} messages`);
            }
          })
          .catch(err => console.warn('Final refresh failed:', err));
      },
      onError(err, isPartial){
        cancelUploadTimeout();
        const errMsg = err && err.message ? err.message : (typeof err === 'string' ? err : '');
        const uploadJob = imageUploadId ? state.uploadJobs.get(imageUploadId) : null;
        const alreadyFinished = assistantMessage.is_complete || !!assistantMessage.content;
        if (alreadyFinished || (uploadJob && uploadJob.completed)) {
          // Ignore late/duplicate errors for requests that already produced output
          logActivity(`Ignoring late chat error after completion: ${errMsg || 'unknown'}`, false);
          cleanupUpload({ removeStatus: true });
          return;
        }
        cleanupUpload({ removeStatus: true });
        if (imageUploadId && !(uploadJob && uploadJob.completed)) {
          renderUploadFailureMessage(errMsg || 'Upload failed before chat started.', imageUploadId);
        }
        const isAuthError = typeof errMsg === 'string' && /not_authenticated/i.test(errMsg);
        if (isAuthError){
          stopTyping();
          const promptText = '**Session expired.** Please reload to re-authenticate.';
          renderMarkdown(assistantBody, promptText);
          addReloadAction(assistantBody);
          setBusy(false);
          if (state.modelStatus.phase !== 'idle'){
            setModelStatus('idle', { model: modelLabel });
          }
          assistantMessage.content = promptText;
          assistantMessage.streaming = false;
          assistantMessage.is_complete = false;
          logActivity('Session expired – prompt reload to re-authenticate', false);
          return;
        }

        // Queue any remaining untyped content before stopping
        if (accumulated && accumulated.length > currentTypingText.length) {
          const remaining = accumulated.substring(currentTypingText.length);
          queueTypingChunk(remaining);
          queueTypingChunk('\n\n*[Connection interrupted. Refreshing...]*');
          endTyping(); // Let typing finish gracefully
        } else {
          // Stop typing animation immediately
          stopTyping();
          // Always preserve partial message if we have accumulated content
          if (accumulated) {
            renderMarkdown(assistantBody, accumulated + `\n\n*[Connection interrupted. Refreshing...]*`);
            logActivity(`Partial response received (${accumulated.length} chars), refreshing from DB...`);
          } else {
            // Show loading message instead of error
            renderMarkdown(assistantBody, `*Reconnecting and checking database...*`);
            logActivity(`Connection timeout, requesting DB refresh...`);
          }
        }

        // Auto DB refresh after error to recover content (merge, don't replace)
        setTimeout(() => {
          nknSendRequestWithRetry({ event: 'chat.refresh' }, { maxAttempts: 3, timeoutMs: 8000 })
            .then(refreshData => {
              if (refreshData) {
                if (refreshData.messages) {
                  state.messages = mergeMessages(state.messages, refreshData.messages);
                }
                if (refreshData.sessions) {
                  state.sessions = refreshData.sessions;
                  renderSessions();
                }
                if (refreshData.current_session_id) state.currentSessionId = refreshData.current_session_id;
                syncCurrentModelFromState(refreshData.current_session_model);
                renderHistory();
                logActivity(`Auto DB refresh: restored ${state.messages.length} messages`);
                setBusy(false);
              } else {
                renderMarkdown(assistantBody, `**Error:** Unable to connect to relay`);
                setBusy(false);
              }
            })
            .catch(refreshErr => {
              console.warn('Auto DB refresh failed:', refreshErr);
              renderMarkdown(assistantBody, `**Error:** ${err.message || err}`);
              logActivity(`DB refresh failed: ${refreshErr.message || refreshErr}`, false);
              setBusy(false);
            });
        }, 500); // Small delay to allow any pending writes to complete
        if (state.modelStatus.phase !== 'error'){
          setModelStatus('idle', { model: modelLabel });
        }
        assistantMessage.content = accumulated || assistantMessage.content || '';
        assistantMessage.streaming = false;
        assistantMessage.is_complete = false;
      },
      onStatus(statusPayload){
        applyModelStatusEvent(statusPayload);
        syncTypingPlaceholderToModelStatus(statusPayload);
        if (statusPayload && statusPayload.phase === 'loading') {
          assistantMessage.streaming = true;
          assistantMessage.is_complete = false;
        }
      }
    };

  const payload = {
    message: text,
    user_uuid: userMsgId,
    assistant_uuid: assistantMsgId,
    thinking: caps.supports_thinking ? state.thinkingEnabled : false
  };
  if (imageUploadId){
    payload.image_upload_id = imageUploadId;
    payload.image_mime = pendingImageInfo?.type || '';
    payload.image_name = pendingImageInfo?.name || 'image';
    if (imageThumb) payload.image_thumb = imageThumb;
  }
  if (caps.supports_tools){
    const tools = getActiveTools();
    if (tools.length){
      payload.tools = tools;
    }
  }
  streamViaNkn(payload, handlers);
} finally {
  state.pendingSend = false;
}
}

function decodePayload(payload){
  if (typeof payload === 'string') return payload;
  if (payload instanceof Uint8Array) return new TextDecoder().decode(payload);
  if (payload && payload.payload) return decodePayload(payload.payload);
  return '';
}

function escapeHtml(str){
  return String(str || '').replace(/[&<>"']/g, (ch) => {
    switch (ch) {
      case '&': return '&amp;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '"': return '&quot;';
      case "'": return '&#39;';
      default: return ch;
    }
  });
}

async function ensureNovioClient(){
  if (!preferNovioTransport()){
    throw new Error('Novio wallet unavailable');
  }
  if (!novioClient) {
    throw new Error('Novio SDK unavailable');
  }
  state.nkn.transport = 'novio';
  if (state.nkn.client === novioClient && state.nkn.ready) return novioClient;
  if (state.nkn.connectPromise && usingNovioTransport()) return state.nkn.connectPromise;
  if (!window.novio || !window.novio.isConnected){
    setNknStatus('yellow', 'Open Novio wallet to connect…');
    logActivity('Waiting for Novio wallet connection…');
  } else {
    setNknStatus('yellow', 'Finalizing Novio channel…');
  }

  const promise = Promise.race([
    novioClient.ClientConnected,
    new Promise((_, reject) => setTimeout(() => reject(new Error('Novio wallet not connected')), 8000)),
  ]).then(() => {
    if (state.nkn.client && state.nkn.client !== novioClient && state.nkn.client.close){
      try { state.nkn.client.close(); } catch (_) {}
    }
    state.nkn.client = novioClient;
    state.nkn.ready = true;
    state.novio.ready = true;
    state.nkn.addr = (window.novio && window.novio.address) ? window.novio.address : state.nkn.addr || '';
    toast(state.nkn.addr ? `Novio connected · ${state.nkn.addr.slice(0, 12)}…` : 'Novio connected');
    setNknStatus('green', 'Connected via Novio');
    startNknHealthMonitor();
    return novioClient;
  });

  state.nkn.connectPromise = promise.finally(() => { state.nkn.connectPromise = null; });
  return promise;
}

async function ensureDirectNknClient(){
  state.nkn.transport = 'direct';
  if (state.nkn.client && state.nkn.ready && !usingNovioTransport()) return state.nkn.client;
  if (state.nkn.connectPromise && !usingNovioTransport()) return state.nkn.connectPromise;
  if (!window.nkn || !window.nkn.MultiClient){
    throw new Error('nkn-sdk not loaded');
  }
  setNknStatus('yellow', 'Connecting to NKN…');
  toast('Connecting to NKN…', true);
  const promise = new Promise((resolve, reject) => {
    try {
      const client = new window.nkn.MultiClient({
        identifier: 'inference-web',
        seed: state.nkn.seed,
        numSubClients: 8,
        msgCacheSize: 2048,
        msgCacheExpiration: 300000,
        msgHoldingSeconds: 60,
        reconnectIntervalMin: 1000,
        reconnectIntervalMax: 6000,
        responseTimeout: 15000,
      });
      state.nkn.client = client;
      let resolved = false;
      client.on('connect', () => {
        state.nkn.ready = true;
        state.nkn.transport = 'direct';
        state.nkn.healthFailures = 0;
        state.nkn.addr = String(client.addr || '');
        toast(state.nkn.addr ? `NKN connected · ${state.nkn.addr.slice(0, 12)}…` : 'NKN connected');
        setNknStatus('green', 'Connected');

        // Check relay and trigger auto-login if credentials are saved
        checkRelay()
          .then(async () => {
            await ensureAutoLogin('nkn connect').catch(() => {});
            if (state.session) {
              logActivity('Auto-login successful');
              return;
            }
            if (els.loginModal && els.loginModal.classList.contains('state-connect')) {
              switchLoginModalState('auth');
              logActivity('Connected! Please login or register to continue.');
            }
          })
          .catch((err) => toast(err.message || 'Relay probe failed', false));

        state.nkn.backoffMs = state.nkn.baseBackoffMs;
        if (state.nkn.reconnectTimer){
          clearTimeout(state.nkn.reconnectTimer);
          state.nkn.reconnectTimer = null;
        }
        startNknHealthMonitor();
        if (!resolved){ resolved = true; resolve(client); }
      });
      client.onMessage(({src, payload, payloadType}) => handleNknMessage(src, payload));
      client.on('close', () => {
        if (usingNovioTransport()) return;
        state.nkn.ready = false;
        state.nkn.client = null;
        state.nkn.addr = '';
        toast('NKN disconnected', false);
        setNknStatus('red', 'Disconnected');
        stopNknHealthMonitor();
        scheduleNknReconnect('close');
      });
      if (typeof client.onWsError === 'function'){
        client.onWsError((clientId, ev) => {
          let cid = 'unknown';
          if (typeof clientId === 'string') {
            cid = clientId;
          } else if (clientId && typeof clientId === 'object') {
            cid = clientId.id || clientId.addr || clientId.address || clientId.name || clientId._name || 'object';
            if (!cid && clientId.url) cid = clientId.url;
            if (!cid && clientId._url) cid = clientId._url;
          }
          let detail = '';
          if (ev) {
            detail = ev.message || ev.type || ev.code || ev.error || '';
            if (!detail && ev.target && (ev.target.url || ev.target._url)) {
              detail = ev.target.url || ev.target._url;
            }
            if (ev.error && ev.error.code) {
              detail = detail ? `${detail} (${ev.error.code})` : ev.error.code;
            }
          }
          console.warn('nkn ws error', cid, detail || ev);
          logActivity(`NKN websocket error (${cid}): ${String(detail || '') || 'unknown'}, reconnecting`, false);
          resetNknClient();
        });
      }
      client.on('error', (err) => {
        if (usingNovioTransport()) return;
        console.error('nkn error', err);
        state.nkn.ready = false;
        state.nkn.addr = '';
        toast('NKN error', false);
        setNknStatus('red', 'Error');
        stopNknHealthMonitor();
        scheduleNknReconnect('error');
        if (!resolved){ resolved = true; reject(err); }
      });
    } catch (err){
      reject(err);
    }
  });
  state.nkn.connectPromise = promise.finally(() => { state.nkn.connectPromise = null; });
  return promise;
}

async function ensureNknClient(){
  if (preferNovioTransport()){
    try {
      return await ensureNovioClient();
    } catch (err){
      const alreadyForced = state.nkn.forceDirect;
      state.nkn.forceDirect = true;
      if (!alreadyForced){
        logActivity(`Novio path unavailable (${err.message || err}); falling back to direct NKN`, false);
      }
    }
  }
  return ensureDirectNknClient();
}

function handleNknMessage(src, payload){
  const text = decodePayload(payload);
  let data;
  try { data = JSON.parse(text); }
  catch {
    // Return false to prevent auto-ACK for malformed messages
    return false;
  }
  const event = data.event;
  const reqId = data.id;
  if (!reqId){
    if (event === 'relay.info'){
      toast('Relay info received');
    } else if (event === 'hardware.stats'){
      updateHardwareStats(data.stats || data);
    }
    // Return false - no auto-ACK needed
    return false;
  }
  const ctx = state.nkn.pending.get(reqId);
  if (!ctx) {
    if (event === 'model.status'){
      applyModelStatusEvent(data);
    } else if (event === 'image.upload.ack'){
      // unsolicited ack; ignore
      logActivity(`DM ← image.upload.ack unsolicited upload_id=${data.upload_id || data.uploadId || 'unknown'} received=${data.received} total=${data.total}`);
    }
    // Return false - message not for us
    return false;
  }

  if (ctx.kind === 'stream'){
    if (event === 'chat.tool_calls'){
      handleToolCallsEvent(data.tool_calls || data.toolCalls || []);
    } else if (event === 'chat.delta'){
      // Pass delta with sequence number and batch size
      ctx.handlers.onDelta(data.delta || '', data.seq, data.batch_size);
    } else if (event === 'chat.done'){
      ctx.handlers.onDone(data.total_seq, data.final_content);
      state.nkn.pending.delete(reqId);
      logActivity(`Chat stream done (${reqId})`);
    } else if (event === 'chat.error'){
      // Pass error with partial flag
      ctx.handlers.onError(new Error(data.error || 'relay error'), data.partial);
      state.nkn.pending.delete(reqId);
      logActivity(`Chat stream error (${data.error || 'unknown'})`, false);
    } else if (event === 'chat.ack'){
      // ignore
    } else if (event === 'model.status'){
      if (ctx.handlers.onStatus){
        ctx.handlers.onStatus(data);
      } else {
        applyModelStatusEvent(data);
      }
    } else if (event === 'image.ready'){
      // optional hook if backend sends it
      const uploadId = data.upload_id || data.uploadId;
      if (uploadId){
        cancelUploadGuard(uploadId);
        markUploadCompleted(uploadId);
        completeUploadStatus(uploadId);
      }
    }
  } else if (ctx.kind === 'request'){
    clearTimeout(ctx.timer);
    state.nkn.pending.delete(reqId);
    if (event && event.endsWith('.error')){
      const errMsg = data.message || data.error || 'relay error';
      logActivity(`DM error (${event}): ${errMsg}`, false);
      ctx.reject(new Error(errMsg));
    } else if (event === 'chat.error'){
      const errMsg = data.error || 'relay error';
      logActivity(`DM error (${errMsg})`, false);
      ctx.reject(new Error(errMsg));
    } else {
      logActivity(`DM ← ${event || 'response'} (${reqId})`);
      ctx.resolve(data);
    }
  }

  // Return false to prevent automatic ACK - we handle responses manually
  return false;
}

if (typeof NovioClient !== 'undefined' && !novioClient){
  novioClient = new NovioClient();
  novioClient.onMessage(({ src, payload }) => handleNknMessage(src, payload));
  novioClient.Connected.then(() => {
    setNknStatus('yellow', 'Novio wallet connected');
    logActivity('Novio wallet detected, preparing client channel…');
  }).catch(() => {});
  novioClient.ClientConnected.then(() => {
    state.nkn.transport = 'novio';
    state.novio.ready = true;
    if (state.nkn.client && state.nkn.client !== novioClient && state.nkn.client.close){
      try { state.nkn.client.close(); } catch (_) {}
    }
    state.nkn.client = novioClient;
    state.nkn.ready = true;
    state.nkn.addr = (window.novio && window.novio.address) ? window.novio.address : state.nkn.addr || '';
    startNknHealthMonitor();
    checkRelay().catch((err) => logActivity(`Relay probe failed: ${err.message || err}`, false));
  }).catch(() => {});
  novioClient.ClientDisconnected.then(() => {
    if (!usingNovioTransport()) return;
    state.nkn.ready = false;
    state.novio.ready = false;
    state.nkn.client = null;
    state.nkn.addr = '';
    setNknStatus('red', 'Novio disconnected');
    logActivity('Novio channel dropped; reopen the wallet to reconnect', false);
  }).catch(() => {});
}

function sendViaTransport(client, message){
  const serialized = typeof message === 'string' ? message : JSON.stringify(message);
  if (!client){
    return Promise.reject(new Error('NKN client unavailable'));
  }
  try {
    const result = usingNovioTransport()
      ? client.send(state.relay, serialized, { noReply: true })
      : client.send(state.relay, serialized);
    if (result && typeof result.then === 'function'){
      return result;
    }
    return Promise.resolve();
  } catch (err){
    return Promise.reject(err);
  }
}

async function nknSendRequest(body, timeoutMs=20000){
  if (!requireRelay()) throw new Error('Relay address required');
  const maxAttempts = 3;

  async function dispatch(attempt){
    const id = `req-${Date.now()}-${Math.floor(Math.random()*1000)}`;
    logActivity(`DM → ${body.event || 'request'} (${id})`);
    const client = await ensureNknClient();
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        state.nkn.pending.delete(id);
        reject(new Error('Relay request timeout'));
      }, timeoutMs);
      state.nkn.pending.set(id, { kind: 'request', resolve, reject, timer });
      sendViaTransport(client, Object.assign({ id }, body)).catch((err) => {
        clearTimeout(timer);
        state.nkn.pending.delete(id);
        if (attempt < maxAttempts && shouldRetryNknError(err)){
          logActivity(`Send failed (${err.message || err}). Retrying…`, false);
          resetNknClient();
          dispatch(attempt + 1).then(resolve).catch(reject);
        } else {
          reject(err);
        }
      });
    });
  }

  return dispatch(1);
}

async function nknSendRequestWithRetry(body, options = {}){
  const maxAttempts = options.maxAttempts || 5;
  const timeoutMs = options.timeoutMs || 20000;
  const backoffMs = options.backoffMs || 1000;

  if (!requireRelay()) throw new Error('Relay address required');
  await ensureNknClient();

  for (let attempt = 1; attempt <= maxAttempts; attempt++){
    try {
      const id = `req-${Date.now()}-${Math.floor(Math.random()*10000)}`;
      logActivity(`SYN → ${body.event || 'request'} attempt ${attempt}/${maxAttempts} (${id})`);

      const client = state.nkn.client;
      if (!client) throw new Error('NKN client not ready');

      const response = await new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
          state.nkn.pending.delete(id);
          reject(new Error('Relay request timeout'));
        }, timeoutMs);

        state.nkn.pending.set(id, {
          kind: 'request',
          resolve: (data) => {
            clearTimeout(timer);
            resolve(data);
          },
          reject: (err) => {
            clearTimeout(timer);
            reject(err);
          },
          timer,
          attempt,
          startTime: Date.now()
        });

        const message = Object.assign({ id }, body);
        sendViaTransport(client, message).catch((sendErr) => {
          clearTimeout(timer);
          state.nkn.pending.delete(id);
          reject(sendErr);
        });
      });

      logActivity(`ACK ← ${body.event || 'response'} (${id})`, true);
      return response;

    } catch (err){
      const isLastAttempt = attempt >= maxAttempts;
      const shouldRetry = shouldRetryNknError(err);

      if (isLastAttempt || !shouldRetry){
        logActivity(`Request failed after ${attempt} attempts: ${err.message || err}`, false);
        throw err;
      }

      const delay = backoffMs * Math.pow(1.5, attempt - 1);
      logActivity(`Retry ${attempt}/${maxAttempts} failed (${err.message}), waiting ${delay}ms...`, false);
      await new Promise(resolve => setTimeout(resolve, delay));

      // Ensure NKN client is healthy before retry
      try {
        await ensureNknClient();
      } catch (clientErr){
        logActivity(`NKN client recovery failed: ${clientErr.message}`, false);
      }
    }
  }

  throw new Error('Request failed after all retry attempts');
}

async function streamViaNkn(payload, handlers){
  if (!requireRelay()){
    handlers.onError(new Error('Relay address required'));
    return;
  }
  const maxAttempts = 3;

  async function dispatch(attempt){
    const client = await ensureNknClient();
    const reqId = `chat-${Date.now()}-${Math.floor(Math.random()*1000)}`;
    state.nkn.pending.set(reqId, { kind: 'stream', handlers });
    const message = Object.assign({ event: 'chat.begin', id: reqId }, payload);
    logActivity(`Chat stream start (${reqId})`);
    try {
      await sendViaTransport(client, message);
    } catch (err){
      state.nkn.pending.delete(reqId);
      if (attempt < maxAttempts && shouldRetryNknError(err)){
        logActivity(`Chat send failed (${err.message || err}). Retrying…`, false);
        resetNknClient();
        await new Promise(resolve => setTimeout(resolve, 500 * attempt)); // Backoff
        return dispatch(attempt + 1);
      }
      throw err;
    }
    return reqId;
  }

  try {
    await dispatch(1);
  } catch (err){
    // On complete send failure, trigger auto-refresh instead of showing error
    logActivity(`Chat send failed after retries, triggering auto DB refresh...`, false);
    handlers.onError(err);
  }
}

function copyAddress(){
  if (!state.relay){
    toast('No address to copy', false);
    return;
  }
  if (!navigator.clipboard){
    toast('Clipboard unavailable', false);
    return;
  }
  navigator.clipboard.writeText(state.relay).then(() => {
    toast('Relay address copied');
  }).catch((err) => {
    toast('Copy failed', false);
    console.error(err);
  });
}

function init(){
  els.pubkeyInput.value = state.relayPubkey;

  prefillSavedCreds();
  bindChatInputEvents();
  ensureInputModeMatchesViewport();
  setupChatScrollHandling();
  if (state.savedCreds){
    logActivity('Saved credentials loaded');
  }

  syncRelayInputs();
  renderHistory();
  updateSessionUI();
  updateToolVisibility();
  updateToolsChip();
  updatePendingImageUI();
  setSidebarHidden(isMobileViewport());

  // Auto-login will happen in checkRelay() after NKN connects
}

// === Session Management ===

function isMobileViewport(){
  return window.matchMedia('(max-width: 640px)').matches;
}

function ensureInputModeMatchesViewport(){
  if (!els.input) return;
  if (isMobileViewport() && els.input.tagName.toLowerCase() === 'textarea'){
    downgradeChatInputToInput();
  }
}

function setSidebarHidden(hidden){
  if (!els.sessionsSidebar) return;
  els.sessionsSidebar.classList.toggle('hidden', hidden);
  if (els.chatInterface) {
    els.chatInterface.classList.toggle('sidebar-hidden', hidden);
  }
}

function toggleSidebar(){
  if (!els.sessionsSidebar) return;
  const willHide = !els.sessionsSidebar.classList.contains('hidden');
  setSidebarHidden(willHide);
}

function renderSessions(){
  if (!state.sessions || state.sessions.length === 0) {
    els.sessionsList.innerHTML = '<div style="padding: 12px; text-align: center; color: var(--text-muted); font-size: 12px;">No chat sessions yet</div>';
    return;
  }

  els.sessionsList.innerHTML = state.sessions.map(session => {
    const isActive = session.id === state.currentSessionId;
    const title = session.title || 'New Chat';
    const messageCount = session.message_count || 0;
    const modelLabel = session.model || getModelLabel();

    return `
      <div class="session-item ${isActive ? 'active' : ''}" data-session-id="${session.id}">
        <div class="session-item-content">
          <div class="session-item-title">${title}</div>
          <div class="session-item-meta">${messageCount} messages · ${modelLabel}</div>
        </div>
        <button class="session-item-delete" data-session-id="${session.id}" title="Delete">×</button>
      </div>
    `;
  }).join('');

  // Add click handlers
  document.querySelectorAll('.session-item').forEach(item => {
    const sessionId = parseInt(item.dataset.sessionId);
    item.addEventListener('click', (e) => {
      if (!e.target.classList.contains('session-item-delete')) {
        switchToSession(sessionId);
        if (isMobileViewport()) {
          setSidebarHidden(true);
        }
      }
    });
  });

  document.querySelectorAll('.session-item-delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const sessionId = parseInt(btn.dataset.sessionId);
      deleteSession(sessionId);
    });
  });
}

async function createNewSession(){
  if (!state.session) return;
  try {
    const resp = await nknSendRequestWithRetry({ event: 'session.create', model: getModelLabel() });
    if (resp.sessions) state.sessions = resp.sessions;
    if (resp.current_session_id) state.currentSessionId = resp.current_session_id;
    if (resp.messages) {
      state.messages = (resp.messages || []).map(msg => normalizeMessage(msg, resp.current_session_model));
    }
    syncCurrentModelFromState(resp.current_session_model || getModelLabel());
    renderSessions();
    renderHistory();
    toast('New chat started');
    logActivity(`Created new session ${resp.session_id}`);
  } catch (err) {
    toast(`Failed to create session: ${err.message}`, false);
  }
}

async function switchToSession(sessionId){
  if (!state.session || sessionId === state.currentSessionId) return;
  // Stop any active typing animation when switching sessions
  stopTyping();
  try {
    const resp = await nknSendRequestWithRetry({ event: 'session.switch', session_id: sessionId });
    if (resp.current_session_id) state.currentSessionId = resp.current_session_id;
    if (resp.sessions) state.sessions = resp.sessions;
    if (resp.messages) {
      state.messages = (resp.messages || []).map(msg => normalizeMessage(msg, resp.current_session_model));
    }
    syncCurrentModelFromState(resp.current_session_model);
    renderSessions();
    renderHistory();
    logActivity(`Switched to session ${sessionId}`);
  } catch (err) {
    toast(`Failed to switch session: ${err.message}`, false);
  }
}

async function deleteSession(sessionId){
  if (!state.session) return;
  if (!confirm('Delete this chat session? This cannot be undone.')) return;
  try {
    const resp = await nknSendRequestWithRetry({ event: 'session.delete', session_id: sessionId });
    if (resp.sessions) state.sessions = resp.sessions;
    if (resp.current_session_id) state.currentSessionId = resp.current_session_id;
    if (resp.messages) {
      state.messages = (resp.messages || []).map(msg => normalizeMessage(msg, resp.current_session_model || getModelLabel()));
    }
    syncCurrentModelFromState(resp.current_session_model);
    renderSessions();
    renderHistory();
    toast('Session deleted');
    logActivity(`Deleted session ${sessionId}`);
  } catch (err) {
    toast(`Failed to delete session: ${err.message}`, false);
  }
}

// === Event Handlers ===

els.pubkeyInput.addEventListener('input', syncRelayInputs);
if (els.copyAddress) els.copyAddress.addEventListener('click', copyAddress);
els.sidebarToggle.addEventListener('click', toggleSidebar);
if (els.sidebarInlineToggle) els.sidebarInlineToggle.addEventListener('click', toggleSidebar);
els.newChatBtn.addEventListener('click', async () => {
  await createNewSession();
  if (isMobileViewport()) {
    setSidebarHidden(true);
  }
});
if (els.novioConnect){
  els.novioConnect.addEventListener('novio-error', (e) => {
    const detail = e?.detail?.error || 'unknown';
    logActivity(`Novio wallet error: ${detail}`, false);
  });
  document.addEventListener('NovioSignInSuccess', () => {
    state.nkn.transport = 'novio';
    state.nkn.forceDirect = false;
    ensureNknClient().catch((err) => logActivity(`Novio connect failed: ${err.message || err}`, false));
  });
}
els.connectBtn.addEventListener('click', async () => {
  if (!requireRelay()) return;
  try {
    await ensureNknClient();
    await checkRelay();
    // Switch to auth state after successful connection
    switchLoginModalState('auth');
    logActivity('Connected! Please login or register to continue.');
  } catch (err){
    toast(String(err), false);
  }
});
if (els.guestConnectBtn){
  els.guestConnectBtn.addEventListener('click', async () => {
    if (!requireRelay()) return;
    state.nkn.transport = 'direct';
    state.nkn.forceDirect = true;
    logActivity('Guest connect: forcing direct NKN path');
    try {
      await ensureDirectNknClient();
      await checkRelay();
      switchLoginModalState('auth');
      logActivity('Connected without wallet; please login or register to continue.');
    } catch (err){
      toast(String(err), false);
    }
  });
}
els.registerForm.addEventListener('submit', handleRegister);
els.loginForm.addEventListener('submit', handleLogin);
els.logoutBtn.addEventListener('click', handleLogout);
els.form.addEventListener('submit', handleSend);
els.showRegisterBtn.addEventListener('click', showRegisterForm);
els.showLoginBtn.addEventListener('click', showLoginForm);
if (els.attachImageBtn && els.imageInput){
  els.attachImageBtn.addEventListener('click', () => {
    if (state.currentCapabilities.supports_images){
      els.imageInput.click();
    } else {
      toast('Current model does not support images', false);
    }
  });
  els.imageInput.addEventListener('change', handleImageSelected);
}
if (els.removeImageBtn) els.removeImageBtn.addEventListener('click', removePendingImage);
if (els.manageToolsBtn) els.manageToolsBtn.addEventListener('click', openToolsModal);
if (els.toolsModalClose) els.toolsModalClose.addEventListener('click', closeToolsModal);
if (els.toolsModal){
  els.toolsModal.addEventListener('click', (e) => {
    if (e.target === els.toolsModal) closeToolsModal();
  });
}
if (els.toolForm){
  els.toolForm.addEventListener('submit', handleToolSubmit);
}
if (els.thinkingToggle){
  els.thinkingToggle.addEventListener('change', (e) => {
    state.thinkingEnabled = !!e.target.checked;
    if (els.thinkingChip){
      els.thinkingChip.classList.toggle('on', state.thinkingEnabled);
    }
  });
}
if (els.modelStatusPill){
  els.modelStatusPill.setAttribute('tabindex', '0');
  els.modelStatusPill.addEventListener('click', (e) => {
    e.preventDefault();
    openModelModal();
  });
  els.modelStatusPill.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      openModelModal();
    }
  });
}
if (els.modelModalClose) els.modelModalClose.addEventListener('click', closeModelModal);
if (els.modelModal) {
  els.modelModal.addEventListener('click', (e) => {
    if (e.target === els.modelModal) closeModelModal();
  });
}
if (els.themeToggle){
  els.themeToggle.addEventListener('click', () => {
    applyTheme(state.theme === 'dark' ? 'light' : 'dark');
    saveUserPreferences();
  });
}
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      closeModelModal();
      closeToolsModal();
    }
  });

function setViewportHeight(){
  const vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
}
window.addEventListener('resize', () => {
  setViewportHeight();
  ensureInputModeMatchesViewport();
});
window.addEventListener('orientationchange', () => {
  setViewportHeight();
  ensureInputModeMatchesViewport();
});
setViewportHeight();

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (autoRefreshTimer) {
    clearInterval(autoRefreshTimer);
    autoRefreshTimer = null;
  }
});

init();
</script>
</body>
</html>
